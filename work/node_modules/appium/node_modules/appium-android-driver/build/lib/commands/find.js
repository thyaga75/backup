'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _mobileJsonWireProtocol = require('mobile-json-wire-protocol');

var commands = {},
    helpers = {},
    extensions = {};

// stategy: locator strategy
// selector: the actual selector for finding an element
// mult: multiple elements or just one?
// context: finding an element from the root context? or starting from another element
helpers.findElOrEls = function callee$0$0(strategy, selector, mult) {
  var context = arguments.length <= 3 || arguments[3] === undefined ? '' : arguments[3];
  var params, element, doFind;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // throws error if not valid, uses this.locatorStrategies
        this.validateLocatorStrategy(strategy);

        if (!(strategy === "xpath" && context)) {
          context$1$0.next = 3;
          break;
        }

        throw new Error("Cannot use xpath locator strategy from an element. " + "It can only be used from the root element");

      case 3:
        if (selector) {
          context$1$0.next = 5;
          break;
        }

        throw new Error("Must provide a selector when finding elements");

      case 5:
        params = {
          strategy: strategy,
          selector: selector,
          context: context,
          multiple: mult
        };
        element = undefined;

        doFind = function doFind() {
          return _regeneratorRuntime.async(function doFind$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.bootstrap.sendAction('find', params));

              case 3:
                element = context$2$0.sent;
                context$2$0.next = 11;
                break;

              case 6:
                context$2$0.prev = 6;
                context$2$0.t0 = context$2$0['catch'](0);

                if (!(context$2$0.t0.message && context$2$0.t0.message.match(/An element could not be located/))) {
                  context$2$0.next = 10;
                  break;
                }

                return context$2$0.abrupt('return', false);

              case 10:
                throw context$2$0.t0;

              case 11:
                if (!mult) {
                  context$2$0.next = 15;
                  break;
                }

                return context$2$0.abrupt('return', element && element.length !== 0);

              case 15:
                return context$2$0.abrupt('return', !_lodash2['default'].isNull(element));

              case 16:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this, [[0, 6]]);
        };

        context$1$0.prev = 8;
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.implicitWaitForCondition(doFind));

      case 11:
        context$1$0.next = 20;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](8);

        if (!(context$1$0.t0.message && context$1$0.t0.message.match(/Condition unmet/))) {
          context$1$0.next = 19;
          break;
        }

        // only get here if we are looking for multiple elements
        // condition was not met setting res to empty array
        element = [];
        context$1$0.next = 20;
        break;

      case 19:
        throw context$1$0.t0;

      case 20:
        if (!mult) {
          context$1$0.next = 24;
          break;
        }

        return context$1$0.abrupt('return', element);

      case 24:
        if (!(!element || _lodash2['default'].size(element) === 0)) {
          context$1$0.next = 26;
          break;
        }

        throw new _mobileJsonWireProtocol.errors.NoSuchElementError();

      case 26:
        return context$1$0.abrupt('return', element);

      case 27:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[8, 13]]);
};

_Object$assign(extensions, commands, helpers);
exports.commands = commands;
exports.helpers = helpers;
exports['default'] = extensions;

// we are fine with this, just indicate a retry

// we want to return false if we want to potentially try again
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9maW5kLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztzQkFBYyxRQUFROzs7O3NDQUNDLDJCQUEyQjs7QUFHbEQsSUFBSSxRQUFRLEdBQUcsRUFBRTtJQUFFLE9BQU8sR0FBRyxFQUFFO0lBQUUsVUFBVSxHQUFHLEVBQUUsQ0FBQzs7Ozs7O0FBTWpELE9BQU8sQ0FBQyxXQUFXLEdBQUcsb0JBQWdCLFFBQVEsRUFBRSxRQUFRLEVBQUUsSUFBSTtNQUFFLE9BQU8seURBQUcsRUFBRTtNQWF0RSxNQUFNLEVBT04sT0FBTyxFQUNQLE1BQU07Ozs7Ozs7QUFuQlYsWUFBSSxDQUFDLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxDQUFDOztjQUVuQyxRQUFRLEtBQUssT0FBTyxJQUFJLE9BQU8sQ0FBQTs7Ozs7Y0FDM0IsSUFBSSxLQUFLLENBQUMscURBQXFELEdBQ3JELDJDQUEyQyxDQUFDOzs7WUFHekQsUUFBUTs7Ozs7Y0FDTCxJQUFJLEtBQUssQ0FBQywrQ0FBK0MsQ0FBQzs7O0FBRzlELGNBQU0sR0FBRztBQUNYLGtCQUFRLEVBQUUsUUFBUTtBQUNsQixrQkFBUSxFQUFFLFFBQVE7QUFDbEIsaUJBQU8sRUFBRSxPQUFPO0FBQ2hCLGtCQUFRLEVBQUUsSUFBSTtTQUNmO0FBRUcsZUFBTzs7QUFDUCxjQUFNLEdBQUcsU0FBVCxNQUFNOzs7Ozs7aURBRVUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQzs7O0FBQXpELHVCQUFPOzs7Ozs7OztzQkFFSCxlQUFJLE9BQU8sSUFBSSxlQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQTs7Ozs7b0RBRTlELEtBQUs7Ozs7OztxQkFNWixJQUFJOzs7OztvREFDQyxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDOzs7b0RBRS9CLENBQUMsb0JBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQzs7Ozs7OztTQUU1Qjs7Ozt5Q0FHTyxJQUFJLENBQUMsd0JBQXdCLENBQUMsTUFBTSxDQUFDOzs7Ozs7Ozs7O2NBRXZDLGVBQUksT0FBTyxJQUFJLGVBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFBOzs7Ozs7O0FBR3JELGVBQU8sR0FBRyxFQUFFLENBQUM7Ozs7Ozs7O2FBTWIsSUFBSTs7Ozs7NENBQ0MsT0FBTzs7O2NBRVYsQ0FBQyxPQUFPLElBQUksb0JBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQTs7Ozs7Y0FDN0IsSUFBSSwrQkFBTyxrQkFBa0IsRUFBRTs7OzRDQUVoQyxPQUFPOzs7Ozs7O0NBRWpCLENBQUM7O0FBRUYsZUFBYyxVQUFVLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3BDLFFBQVEsR0FBUixRQUFRO1FBQUUsT0FBTyxHQUFQLE9BQU87cUJBQ1gsVUFBVSIsImZpbGUiOiJsaWIvY29tbWFuZHMvZmluZC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBlcnJvcnMgfSBmcm9tICdtb2JpbGUtanNvbi13aXJlLXByb3RvY29sJztcblxuXG5sZXQgY29tbWFuZHMgPSB7fSwgaGVscGVycyA9IHt9LCBleHRlbnNpb25zID0ge307XG5cbi8vIHN0YXRlZ3k6IGxvY2F0b3Igc3RyYXRlZ3lcbi8vIHNlbGVjdG9yOiB0aGUgYWN0dWFsIHNlbGVjdG9yIGZvciBmaW5kaW5nIGFuIGVsZW1lbnRcbi8vIG11bHQ6IG11bHRpcGxlIGVsZW1lbnRzIG9yIGp1c3Qgb25lP1xuLy8gY29udGV4dDogZmluZGluZyBhbiBlbGVtZW50IGZyb20gdGhlIHJvb3QgY29udGV4dD8gb3Igc3RhcnRpbmcgZnJvbSBhbm90aGVyIGVsZW1lbnRcbmhlbHBlcnMuZmluZEVsT3JFbHMgPSBhc3luYyBmdW5jdGlvbiAoc3RyYXRlZ3ksIHNlbGVjdG9yLCBtdWx0LCBjb250ZXh0ID0gJycpIHtcbiAgLy8gdGhyb3dzIGVycm9yIGlmIG5vdCB2YWxpZCwgdXNlcyB0aGlzLmxvY2F0b3JTdHJhdGVnaWVzXG4gIHRoaXMudmFsaWRhdGVMb2NhdG9yU3RyYXRlZ3koc3RyYXRlZ3kpO1xuXG4gIGlmIChzdHJhdGVneSA9PT0gXCJ4cGF0aFwiICYmIGNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIHhwYXRoIGxvY2F0b3Igc3RyYXRlZ3kgZnJvbSBhbiBlbGVtZW50LiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiSXQgY2FuIG9ubHkgYmUgdXNlZCBmcm9tIHRoZSByb290IGVsZW1lbnRcIik7XG4gIH1cblxuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGEgc2VsZWN0b3Igd2hlbiBmaW5kaW5nIGVsZW1lbnRzXCIpO1xuICB9XG5cbiAgbGV0IHBhcmFtcyA9IHtcbiAgICBzdHJhdGVneTogc3RyYXRlZ3ksXG4gICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgbXVsdGlwbGU6IG11bHRcbiAgfTtcblxuICBsZXQgZWxlbWVudDtcbiAgbGV0IGRvRmluZCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZWxlbWVudCA9IGF3YWl0IHRoaXMuYm9vdHN0cmFwLnNlbmRBY3Rpb24oJ2ZpbmQnLCBwYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5tZXNzYWdlICYmIGVyci5tZXNzYWdlLm1hdGNoKC9BbiBlbGVtZW50IGNvdWxkIG5vdCBiZSBsb2NhdGVkLykpIHtcbiAgICAgICAgLy8gd2UgYXJlIGZpbmUgd2l0aCB0aGlzLCBqdXN0IGluZGljYXRlIGEgcmV0cnlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIC8vIHdlIHdhbnQgdG8gcmV0dXJuIGZhbHNlIGlmIHdlIHdhbnQgdG8gcG90ZW50aWFsbHkgdHJ5IGFnYWluXG4gICAgaWYgKG11bHQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoICE9PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gIV8uaXNOdWxsKGVsZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICB0cnkge1xuICAgIGF3YWl0IHRoaXMuaW1wbGljaXRXYWl0Rm9yQ29uZGl0aW9uKGRvRmluZCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5tYXRjaCgvQ29uZGl0aW9uIHVubWV0Lykpe1xuICAgICAgLy8gb25seSBnZXQgaGVyZSBpZiB3ZSBhcmUgbG9va2luZyBmb3IgbXVsdGlwbGUgZWxlbWVudHNcbiAgICAgIC8vIGNvbmRpdGlvbiB3YXMgbm90IG1ldCBzZXR0aW5nIHJlcyB0byBlbXB0eSBhcnJheVxuICAgICAgZWxlbWVudCA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11bHQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWVsZW1lbnQgfHwgXy5zaXplKGVsZW1lbnQpID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLk5vU3VjaEVsZW1lbnRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufTtcblxuT2JqZWN0LmFzc2lnbihleHRlbnNpb25zLCBjb21tYW5kcywgaGVscGVycyk7XG5leHBvcnQgeyBjb21tYW5kcywgaGVscGVycyB9O1xuZXhwb3J0IGRlZmF1bHQgZXh0ZW5zaW9ucztcbiJdfQ==