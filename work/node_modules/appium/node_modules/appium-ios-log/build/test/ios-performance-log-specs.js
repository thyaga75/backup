require('source-map-support').install();

'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _this = this;

var _2 = require('..');

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _chai = require('chai');

var _chai2 = _interopRequireDefault(_chai);

var _chaiAsPromised = require('chai-as-promised');

var _chaiAsPromised2 = _interopRequireDefault(_chaiAsPromised);

_chai2['default'].should();
_chai2['default'].use(_chaiAsPromised2['default']);

describe('performance logs', function () {
  var onTimelineEventCb = undefined;
  var log = undefined;
  var remote = {
    startTimeline: _lodash2['default'].noop,
    stopTimeline: _lodash2['default'].noop
  };
  var startTimelineStub = undefined;
  var stopTimelineStub = undefined;
  beforeEach(function () {
    startTimelineStub = _sinon2['default'].stub(remote, 'startTimeline', function callee$2$0(cb) {
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            onTimelineEventCb = cb;

          case 1:
          case 'end':
            return context$3$0.stop();
        }
      }, null, this);
    });
    stopTimelineStub = _sinon2['default'].stub(remote, 'stopTimeline');

    log = new _2.IOSPerformanceLog(remote);
  });
  afterEach(function () {
    startTimelineStub.restore();
    stopTimelineStub.restore();
  });

  it('should be able to start the timeline listening', function callee$1$0() {
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(log.startCapture());

        case 2:
          startTimelineStub.calledOnce.should.be['true'];

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });

  it('should be able to stop the timeline listening', function callee$1$0() {
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(log.startCapture());

        case 2:
          startTimelineStub.calledOnce.should.be['true'];
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap(log.stopCapture());

        case 5:
          stopTimelineStub.calledOnce.should.be['true'];

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });

  it('should capture timeline events', function callee$1$0() {
    var message;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(log.startCapture());

        case 2:
          message = 'Some timeline event';

          onTimelineEventCb(message);

          context$2$0.next = 6;
          return _regeneratorRuntime.awrap(log.getLogs());

        case 6:
          context$2$0.t0 = [message];
          context$2$0.sent.should.eql(context$2$0.t0);

        case 8:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });

  it('should consume timeline events when logs are retrieved', function callee$1$0() {
    var message;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(log.startCapture());

        case 2:
          message = 'Some timeline event';

          onTimelineEventCb(message);

          context$2$0.next = 6;
          return _regeneratorRuntime.awrap(log.getLogs());

        case 6:
          context$2$0.t0 = [message];
          context$2$0.sent.should.eql(context$2$0.t0);
          context$2$0.next = 10;
          return _regeneratorRuntime.awrap(log.getLogs());

        case 10:
          context$2$0.t1 = [];
          context$2$0.sent.should.eql(context$2$0.t1);

        case 12:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QvaW9zLXBlcmZvcm1hbmNlLWxvZy1zcGVjcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O2lCQUVrQyxJQUFJOztxQkFDcEIsT0FBTzs7OztzQkFDWCxRQUFROzs7O29CQUNMLE1BQU07Ozs7OEJBQ0ksa0JBQWtCOzs7O0FBRzdDLGtCQUFLLE1BQU0sRUFBRSxDQUFDO0FBQ2Qsa0JBQUssR0FBRyw2QkFBZ0IsQ0FBQzs7QUFFekIsUUFBUSxDQUFDLGtCQUFrQixFQUFFLFlBQU07QUFDakMsTUFBSSxpQkFBaUIsWUFBQSxDQUFDO0FBQ3RCLE1BQUksR0FBRyxZQUFBLENBQUM7QUFDUixNQUFJLE1BQU0sR0FBRztBQUNYLGlCQUFhLEVBQUUsb0JBQUUsSUFBSTtBQUNyQixnQkFBWSxFQUFFLG9CQUFFLElBQUk7R0FDckIsQ0FBQztBQUNGLE1BQUksaUJBQWlCLFlBQUEsQ0FBQztBQUN0QixNQUFJLGdCQUFnQixZQUFBLENBQUM7QUFDckIsWUFBVSxDQUFDLFlBQU07QUFDZixxQkFBaUIsR0FBRyxtQkFBTSxJQUFJLENBQUMsTUFBTSxFQUFFLGVBQWUsRUFBRSxvQkFBZ0IsRUFBRTs7OztBQUN4RSw2QkFBaUIsR0FBRyxFQUFFLENBQUM7Ozs7Ozs7S0FDeEIsQ0FBQyxDQUFDO0FBQ0gsb0JBQWdCLEdBQUcsbUJBQU0sSUFBSSxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsQ0FBQzs7QUFFdEQsT0FBRyxHQUFHLHlCQUFzQixNQUFNLENBQUMsQ0FBQztHQUNyQyxDQUFDLENBQUM7QUFDSCxXQUFTLENBQUMsWUFBTTtBQUNkLHFCQUFpQixDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQzVCLG9CQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDO0dBQzVCLENBQUMsQ0FBQzs7QUFFSCxJQUFFLENBQUMsZ0RBQWdELEVBQUU7Ozs7OzJDQUM3QyxHQUFHLENBQUMsWUFBWSxFQUFFOzs7QUFDeEIsMkJBQWlCLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLFFBQUssQ0FBQzs7Ozs7OztHQUM3QyxDQUFDLENBQUM7O0FBRUgsSUFBRSxDQUFDLCtDQUErQyxFQUFFOzs7OzsyQ0FDNUMsR0FBRyxDQUFDLFlBQVksRUFBRTs7O0FBQ3hCLDJCQUFpQixDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRSxRQUFLLENBQUM7OzJDQUN0QyxHQUFHLENBQUMsV0FBVyxFQUFFOzs7QUFDdkIsMEJBQWdCLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLFFBQUssQ0FBQzs7Ozs7OztHQUM1QyxDQUFDLENBQUM7O0FBRUgsSUFBRSxDQUFDLGdDQUFnQyxFQUFFO1FBRy9CLE9BQU87Ozs7OzJDQUZMLEdBQUcsQ0FBQyxZQUFZLEVBQUU7OztBQUVwQixpQkFBTyxHQUFHLHFCQUFxQjs7QUFDbkMsMkJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUM7OzsyQ0FFcEIsR0FBRyxDQUFDLE9BQU8sRUFBRTs7OzJCQUFhLENBQUMsT0FBTyxDQUFDOzJCQUFwQixNQUFNLENBQUMsR0FBRzs7Ozs7OztHQUNqQyxDQUFDLENBQUM7O0FBRUgsSUFBRSxDQUFDLHdEQUF3RCxFQUFFO1FBR3ZELE9BQU87Ozs7OzJDQUZMLEdBQUcsQ0FBQyxZQUFZLEVBQUU7OztBQUVwQixpQkFBTyxHQUFHLHFCQUFxQjs7QUFDbkMsMkJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUM7OzsyQ0FFcEIsR0FBRyxDQUFDLE9BQU8sRUFBRTs7OzJCQUFhLENBQUMsT0FBTyxDQUFDOzJCQUFwQixNQUFNLENBQUMsR0FBRzs7MkNBRXpCLEdBQUcsQ0FBQyxPQUFPLEVBQUU7OzsyQkFBYSxFQUFFOzJCQUFiLE1BQU0sQ0FBQyxHQUFHOzs7Ozs7O0dBQ2pDLENBQUMsQ0FBQztDQUNKLENBQUMsQ0FBQyIsImZpbGUiOiJ0ZXN0L2lvcy1wZXJmb3JtYW5jZS1sb2ctc3BlY3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0cmFuc3BpbGU6bW9jaGFcblxuaW1wb3J0IHsgSU9TUGVyZm9ybWFuY2VMb2cgfSBmcm9tICcuLic7XG5pbXBvcnQgc2lub24gZnJvbSAnc2lub24nO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBjaGFpIGZyb20gJ2NoYWknO1xuaW1wb3J0IGNoYWlBc1Byb21pc2VkIGZyb20gJ2NoYWktYXMtcHJvbWlzZWQnO1xuXG5cbmNoYWkuc2hvdWxkKCk7XG5jaGFpLnVzZShjaGFpQXNQcm9taXNlZCk7XG5cbmRlc2NyaWJlKCdwZXJmb3JtYW5jZSBsb2dzJywgKCkgPT4ge1xuICBsZXQgb25UaW1lbGluZUV2ZW50Q2I7XG4gIGxldCBsb2c7XG4gIGxldCByZW1vdGUgPSB7XG4gICAgc3RhcnRUaW1lbGluZTogXy5ub29wLFxuICAgIHN0b3BUaW1lbGluZTogXy5ub29wXG4gIH07XG4gIGxldCBzdGFydFRpbWVsaW5lU3R1YjtcbiAgbGV0IHN0b3BUaW1lbGluZVN0dWI7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIHN0YXJ0VGltZWxpbmVTdHViID0gc2lub24uc3R1YihyZW1vdGUsICdzdGFydFRpbWVsaW5lJywgYXN5bmMgZnVuY3Rpb24gKGNiKSB7XG4gICAgICBvblRpbWVsaW5lRXZlbnRDYiA9IGNiO1xuICAgIH0pO1xuICAgIHN0b3BUaW1lbGluZVN0dWIgPSBzaW5vbi5zdHViKHJlbW90ZSwgJ3N0b3BUaW1lbGluZScpO1xuXG4gICAgbG9nID0gbmV3IElPU1BlcmZvcm1hbmNlTG9nKHJlbW90ZSk7XG4gIH0pO1xuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIHN0YXJ0VGltZWxpbmVTdHViLnJlc3RvcmUoKTtcbiAgICBzdG9wVGltZWxpbmVTdHViLnJlc3RvcmUoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBiZSBhYmxlIHRvIHN0YXJ0IHRoZSB0aW1lbGluZSBsaXN0ZW5pbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgbG9nLnN0YXJ0Q2FwdHVyZSgpO1xuICAgIHN0YXJ0VGltZWxpbmVTdHViLmNhbGxlZE9uY2Uuc2hvdWxkLmJlLnRydWU7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYmUgYWJsZSB0byBzdG9wIHRoZSB0aW1lbGluZSBsaXN0ZW5pbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgbG9nLnN0YXJ0Q2FwdHVyZSgpO1xuICAgIHN0YXJ0VGltZWxpbmVTdHViLmNhbGxlZE9uY2Uuc2hvdWxkLmJlLnRydWU7XG4gICAgYXdhaXQgbG9nLnN0b3BDYXB0dXJlKCk7XG4gICAgc3RvcFRpbWVsaW5lU3R1Yi5jYWxsZWRPbmNlLnNob3VsZC5iZS50cnVlO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGNhcHR1cmUgdGltZWxpbmUgZXZlbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGxvZy5zdGFydENhcHR1cmUoKTtcblxuICAgIGxldCBtZXNzYWdlID0gJ1NvbWUgdGltZWxpbmUgZXZlbnQnO1xuICAgIG9uVGltZWxpbmVFdmVudENiKG1lc3NhZ2UpO1xuXG4gICAgKGF3YWl0IGxvZy5nZXRMb2dzKCkpLnNob3VsZC5lcWwoW21lc3NhZ2VdKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBjb25zdW1lIHRpbWVsaW5lIGV2ZW50cyB3aGVuIGxvZ3MgYXJlIHJldHJpZXZlZCcsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBsb2cuc3RhcnRDYXB0dXJlKCk7XG5cbiAgICBsZXQgbWVzc2FnZSA9ICdTb21lIHRpbWVsaW5lIGV2ZW50JztcbiAgICBvblRpbWVsaW5lRXZlbnRDYihtZXNzYWdlKTtcblxuICAgIChhd2FpdCBsb2cuZ2V0TG9ncygpKS5zaG91bGQuZXFsKFttZXNzYWdlXSk7XG5cbiAgICAoYXdhaXQgbG9nLmdldExvZ3MoKSkuc2hvdWxkLmVxbChbXSk7XG4gIH0pO1xufSk7XG4iXX0=