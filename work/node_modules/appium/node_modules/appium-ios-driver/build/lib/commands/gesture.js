'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _mobileJsonWireProtocol = require('mobile-json-wire-protocol');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _utils = require('../utils');

var commands = {},
    helpers = {},
    extensions = {};
var FLICK_MS = 3000;

commands.nativeTap = function callee$0$0(el) {
  var command;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        el = (0, _utils.unwrapEl)(el);
        command = 'au.tapById(\'' + el + '\')';
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.uiAutoClient.sendCommand(command));

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.click = function callee$0$0(el) {
  var atomsElement;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        el = (0, _utils.unwrapEl)(el);

        if (!this.isWebContext()) {
          context$1$0.next = 13;
          break;
        }

        if (!(this.opts.nativeWebTap && !this.isRealDevice())) {
          context$1$0.next = 7;
          break;
        }

        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.nativeWebTap(el));

      case 5:
        context$1$0.next = 11;
        break;

      case 7:
        atomsElement = this.useAtomsElement(el);
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(this.executeAtom('click', [atomsElement]));

      case 10:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 11:
        context$1$0.next = 19;
        break;

      case 13:
        if (!this.opts.useRobot) {
          context$1$0.next = 17;
          break;
        }

        throw new _mobileJsonWireProtocol.errors.NotYetImplementedError();

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(this.nativeTap(el));

      case 19:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.clickCurrent = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!this.isWebContext()) {
          context$1$0.next = 7;
          break;
        }

        if (!_lodash2['default'].isNull(this.curWebCoords)) {
          context$1$0.next = 3;
          break;
        }

        throw new _mobileJsonWireProtocol.errors.UnknownError('Cannot call click() before calling moveTo() to set coords');

      case 3:
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.clickWebCoords());

      case 5:
        context$1$0.next = 11;
        break;

      case 7:
        if (!(this.curCoords === null)) {
          context$1$0.next = 9;
          break;
        }

        throw new _mobileJsonWireProtocol.errors.UnknownError("Cannot call click() before calling moveTo() to set coords");

      case 9:
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.clickCoords(this.curCoords));

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.clickCoords = function callee$0$0(coords) {
  var opts, command;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!this.opts.useRobot) {
          context$1$0.next = 4;
          break;
        }

        throw new _mobileJsonWireProtocol.errors.NotYetImplementedError();

      case 4:
        opts = coords;

        opts.tapCount = 1;
        opts.duration = 0.3;
        opts.touchCount = 1;
        command = 'au.complexTap(' + JSON.stringify(opts) + ')';
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.uiAutoClient.sendCommand(command));

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.mobileRotation = function callee$0$0(x, y, radius, rotation, touchCount, duration, el) {
  var location, options;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!this.isWebContext()) {
          context$1$0.next = 2;
          break;
        }

        throw new _mobileJsonWireProtocol.errors.NotYetImplementedError();

      case 2:
        el = (0, _utils.unwrapEl)(el);
        location = { 'x': x, 'y': y };
        options = { 'duration': duration, 'radius': radius, 'rotation': rotation, 'touchCount': touchCount };

        if (!el) {
          context$1$0.next = 12;
          break;
        }

        if (!this.isWebContext()) {
          context$1$0.next = 8;
          break;
        }

        throw new _mobileJsonWireProtocol.errors.NotYetImplementedError();

      case 8:
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(this.uiAutoClient.sendCommand(
        // UIAElement.rotateWithOptions takes only one options param.
        'au.getElement(\'' + el + '\').rotateWithOptions(' + JSON.stringify(options) + ')'));

      case 10:
        context$1$0.next = 14;
        break;

      case 12:
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(this.uiAutoClient.sendCommand('target.rotateWithOptions(' + JSON.stringify(location) + ', ' + JSON.stringify(options) + ')'));

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.handleTap = function callee$0$0(gesture) {
  var options, cmdBase, rect, offsetX, offsetY, size, opts, cmd;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        options = gesture.options;
        cmdBase = options.element ? 'au.getElement(\'' + options.element + '\')' : 'UIATarget.localTarget().frontMostApp()';
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.uiAutoClient.sendCommand(cmdBase + '.rect()'));

      case 4:
        rect = context$1$0.sent;
        offsetX = 0.5;
        offsetY = 0.5;
        size = { w: rect.size.width, h: rect.size.height };

        // default options x/y to center, no matter the container
        options.x = options.x || size.w / 2;
        options.y = options.y || size.h / 2;

        offsetX = options.x / size.w;
        offsetY = options.y / size.h;

        opts = {
          tapOffset: {
            x: offsetX,
            y: offsetY
          },
          tapCount: options.count || 1,
          touchCount: 1
        };
        cmd = cmdBase + '.tapWithOptions(' + JSON.stringify(opts) + ')';
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(this.uiAutoClient.sendCommand(cmd));

      case 16:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.performTouch = function callee$0$0(gestures) {
  var touchStateObjects;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!this.isWebContext()) {
          context$1$0.next = 2;
          break;
        }

        throw new _mobileJsonWireProtocol.errors.NotYetImplementedError();

      case 2:
        if (!(gestures.length === 1 && gestures[0].action === 'tap')) {
          context$1$0.next = 6;
          break;
        }

        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.handleTap(gestures[0]));

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.parseTouch(gestures));

      case 8:
        touchStateObjects = context$1$0.sent;
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.uiAutoClient.sendCommand('target.touch(' + JSON.stringify(touchStateObjects) + ')'));

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.parseTouch = function callee$0$0(gestures) {
  var touchStateObjects, finishParsing, needsPoint, cycleThroughGestures;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // `release` is automatic in iOS
        if (_lodash2['default'].last(gestures).action === 'release') {
          gestures.pop();
        }

        touchStateObjects = [];

        finishParsing = function finishParsing() {
          var prevPos = null;

          // we need to change the time (which is now an offset)
          // and the position (which may be an offset)
          var time = 0;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _getIterator(touchStateObjects), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var state = _step.value;

              if (state.touch[0] === false) {
                // if we have no position (this happens with `wait`) we need the previous one
                state.touch[0] = prevPos;
              } else if (state.touch[0].offset && prevPos) {
                // the current position is an offset
                state.touch[0].x += prevPos.x;
                state.touch[0].y += prevPos.y;
              }
              // prevent wait => press => moveto crash
              if (state.touch[0]) {
                delete state.touch[0].offset;
                prevPos = state.touch[0];
              }

              var timeOffset = state.timeOffset;
              time += timeOffset;
              state.time = time;

              delete state.timeOffset;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator['return']) {
                _iterator['return']();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        };

        needsPoint = function needsPoint(action) {
          return _lodash2['default'].includes(['press', 'moveTo', 'tap', 'longPress'], action);
        };

        cycleThroughGestures = function cycleThroughGestures() {
          var gesture, tapPoint, el, command, rect, pos, size, touchStateObject, offset;
          return _regeneratorRuntime.async(function cycleThroughGestures$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                gesture = gestures.shift();

                if (!(typeof gesture === "undefined")) {
                  context$2$0.next = 3;
                  break;
                }

                return context$2$0.abrupt('return', finishParsing());

              case 3:
                tapPoint = false;

                if (!needsPoint(gesture.action)) {
                  context$2$0.next = 27;
                  break;
                }

                el = gesture.options.element;

                if (!el) {
                  context$2$0.next = 20;
                  break;
                }

                command = 'au.getElement(\'' + el + '\').rect()';
                context$2$0.next = 10;
                return _regeneratorRuntime.awrap(this.uiAutoClient.sendCommand(command));

              case 10:
                rect = context$2$0.sent;
                pos = { x: rect.origin.x, y: rect.origin.y };
                size = { w: rect.size.width, h: rect.size.height };

                if (gesture.options.x || gesture.options.y) {
                  tapPoint = {
                    offset: false,
                    x: pos.x + (gesture.options.x || 0),
                    y: pos.y + (gesture.options.y || 0)
                  };
                } else {
                  tapPoint = {
                    offset: false,
                    x: pos.x + size.w / 2,
                    y: pos.y + size.h / 2
                  };
                }

                touchStateObject = {
                  timeOffset: 0.2,
                  touch: [tapPoint]
                };

                touchStateObjects.push(touchStateObject);
                context$2$0.next = 18;
                return _regeneratorRuntime.awrap(cycleThroughGestures());

              case 18:
                context$2$0.next = 25;
                break;

              case 20:
                // iOS expects absolute coordinates, so we need to save these as offsets
                // and then translate when everything is done
                tapPoint = {
                  offset: true,
                  x: gesture.options.x || 0,
                  y: gesture.options.y || 0
                };
                touchStateObject = {
                  timeOffset: 0.2,
                  touch: [tapPoint]
                };

                touchStateObjects.push(touchStateObject);
                context$2$0.next = 25;
                return _regeneratorRuntime.awrap(cycleThroughGestures());

              case 25:
                context$2$0.next = 34;
                break;

              case 27:
                // in this case we need the previous entry's tap point
                tapPoint = false; // temporary marker
                offset = 0.2;

                if (gesture.action === 'wait') {
                  if (typeof gesture.options.ms !== 'undefined' || gesture.options.ms !== null) {
                    offset = parseInt(gesture.options.ms) / 1000;
                  }
                }
                touchStateObject = {
                  timeOffset: offset,
                  touch: [tapPoint]
                };

                touchStateObjects.push(touchStateObject);
                context$2$0.next = 34;
                return _regeneratorRuntime.awrap(cycleThroughGestures());

              case 34:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        };

        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(cycleThroughGestures());

      case 7:
        return context$1$0.abrupt('return', touchStateObjects);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

var mergeStates = function mergeStates(states) {
  var getSlice = function getSlice(states, index) {
    var array = [];
    for (var i = 0; i < states.length; i++) {
      array.push(states[i][index]);
    }

    return array;
  };

  var timeSequence = function timeSequence(states) {
    var seq = [];
    _lodash2['default'].each(states, function (state) {
      var times = _lodash2['default'].map(state, "time");
      seq = _lodash2['default'].union(seq, times);
    });

    return seq.sort();
  };

  // for now we will just assume that the times line up
  var merged = [];
  _lodash2['default'].each(timeSequence(states), function (time, index) {
    var slice = getSlice(states, index);
    var obj = {
      time: time,
      touch: []
    };
    _lodash2['default'].each(slice, function (action) {
      obj.touch.push(action.touch[0]);
    });
    merged.push(obj);
  });
  return merged;
};

commands.performMultiAction = function callee$0$0(actions, el) {
  var states, cycleThroughActions;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!this.isWebContext()) {
          context$1$0.next = 2;
          break;
        }

        throw new _mobileJsonWireProtocol.errors.NotYetImplementedError();

      case 2:

        el = (0, _utils.unwrapEl)(el);
        // TODO: why elementId is not used
        states = [];

        cycleThroughActions = function cycleThroughActions() {
          var action, mergedStates, val;
          return _regeneratorRuntime.async(function cycleThroughActions$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                action = actions.shift();

                if (!(typeof action === "undefined")) {
                  context$2$0.next = 6;
                  break;
                }

                mergedStates = mergeStates(states);
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.uiAutoClient.sendCommand('target.touch(' + JSON.stringify(mergedStates) + ')'));

              case 5:
                return context$2$0.abrupt('return');

              case 6:
                context$2$0.next = 8;
                return _regeneratorRuntime.awrap(this.parseTouch(action));

              case 8:
                val = context$2$0.sent;

                states.push(val);
                context$2$0.next = 12;
                return _regeneratorRuntime.awrap(cycleThroughActions());

              case 12:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2);
        };

        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(cycleThroughActions());

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileScroll = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var direction, el, command;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        direction = opts.direction;
        el = opts.element;

        el = (0, _utils.unwrapEl)(el);

        if (!this.isWebContext()) {
          context$1$0.next = 7;
          break;
        }

        throw new _mobileJsonWireProtocol.errors.NotYetImplementedError();

      case 7:
        direction = direction.charAt(0).toUpperCase() + direction.slice(1);
        command = undefined;

        if (_lodash2['default'].isNull(el) || _lodash2['default'].isUndefined(el)) {
          // By default, scroll the first scrollview.
          command = 'au.scrollFirstView(\'' + direction + '\')';
        } else {
          // if element is defined, call scrollLeft, scrollRight, scrollUp, and scrollDown on the element.
          command = 'au.getElement(\'' + el + '\').scroll' + direction + '()';
        }
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(this.uiAutoClient.sendCommand(command));

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.flick = function callee$0$0(el, xspeed, yspeed, xoffset, yoffset, speed) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        el = (0, _utils.unwrapEl)(el);

        if (!_lodash2['default'].every([el, xoffset, yoffset, speed], function (p) {
          return !_lodash2['default'].isNull(p) && !_lodash2['default'].isUndefined(p);
        })) {
          context$1$0.next = 6;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.flickElement(el, xoffset, yoffset, speed));

      case 4:
        context$1$0.next = 12;
        break;

      case 6:
        if (!_lodash2['default'].every([xspeed, yspeed], function (p) {
          return !_lodash2['default'].isNull(p) && !_lodash2['default'].isUndefined(p);
        })) {
          context$1$0.next = 11;
          break;
        }

        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(this.xySpeedFlick(xspeed, yspeed));

      case 9:
        context$1$0.next = 12;
        break;

      case 11:
        throw new _mobileJsonWireProtocol.errors.UnknownError('Bad flick parameters, pass either (xspeed, yspeed) or (element, xoffset, yoffset, speed)!');

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.xySpeedFlick = function callee$0$0(xSpeed, ySpeed) {
  var command;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        command = 'au.touchFlickFromSpeed(' + xSpeed + ',' + ySpeed + ')';
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_bluebird2['default'].all([this.uiAutoClient.sendCommand(command), _bluebird2['default'].delay(FLICK_MS)]));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.flickElement = function callee$0$0(el, xoffset, yoffset, speed) {
  var command;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        el = (0, _utils.unwrapEl)(el);
        command = "";

        if (!this.isWebContext()) {
          context$1$0.next = 7;
          break;
        }

        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.webFlickElement(el, xoffset, yoffset));

      case 5:
        context$1$0.next = 10;
        break;

      case 7:
        command = 'au.getElement(\'' + el + '\').touchFlick(' + xoffset + ',' + yoffset + ',' + speed + ')';
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_bluebird2['default'].all([this.uiAutoClient.sendCommand(command), _bluebird2['default'].delay(FLICK_MS)]));

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

// TODO: maybe rename this in mjsonwp
commands.mobileShake = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.uiAutoClient.sendCommand("au.shake()"));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.moveTo = function callee$0$0(el) {
  var xoffset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
  var yoffset = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

  var _ref, x, y, coords, atomsElement, relCoords, elPos;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        el = (0, _utils.unwrapEl)(el);

        if (!this.isWebContext()) {
          context$1$0.next = 15;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getLocation(el));

      case 4:
        _ref = context$1$0.sent;
        x = _ref.x;
        y = _ref.y;
        coords = {
          x: x + xoffset,
          y: y + yoffset
        };

        this.curWebCoords = coords;
        atomsElement = this.useAtomsElement(el);
        relCoords = { x: xoffset, y: yoffset };
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.executeAtom('move_mouse', [atomsElement, relCoords]));

      case 13:
        context$1$0.next = 25;
        break;

      case 15:
        if (!(_lodash2['default'].isNull(el) || _lodash2['default'].isUndefined(el))) {
          context$1$0.next = 21;
          break;
        }

        if (this.curCoords) {
          context$1$0.next = 18;
          break;
        }

        throw new _mobileJsonWireProtocol.errors.UnknownException('Current cursor position unknown, please use moveTo with an element the first time.');

      case 18:
        this.curCoords = {
          x: this.curCoords.x + xoffset,
          y: this.curCoords.y + yoffset
        };
        context$1$0.next = 25;
        break;

      case 21:
        context$1$0.next = 23;
        return _regeneratorRuntime.awrap(this.getLocation(el));

      case 23:
        elPos = context$1$0.sent;

        this.curCoords = {
          x: elPos.x + xoffset,
          y: elPos.y + yoffset
        };

      case 25:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

_Object$assign(extensions, commands, helpers);
exports.commands = commands;
exports.helpers = helpers;
exports['default'] = extensions;

// atoms-based clicks don't always work in safari 7

/* TODO */ /*button*/
/* TODO */
// not implemented yet in the web

// start by getting the size and position of the element we are tapping

// default to center
// press, longPress, moveTo and tap all need a position

// not implemented yet in web

// speed is not used because underlying UIATarget.flickFromTo doesn't support it
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9nZXN0dXJlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O3NDQUF1QiwyQkFBMkI7O3NCQUNwQyxRQUFROzs7O3dCQUNSLFVBQVU7Ozs7cUJBQ0MsVUFBVTs7QUFFbkMsSUFBSSxRQUFRLEdBQUcsRUFBRTtJQUFFLE9BQU8sR0FBRyxFQUFFO0lBQUUsVUFBVSxHQUFHLEVBQUUsQ0FBQztBQUNqRCxJQUFNLFFBQVEsR0FBRyxJQUFJLENBQUM7O0FBRXRCLFFBQVEsQ0FBQyxTQUFTLEdBQUcsb0JBQWdCLEVBQUU7TUFFakMsT0FBTzs7OztBQURYLFVBQUUsR0FBRyxxQkFBUyxFQUFFLENBQUMsQ0FBQztBQUNkLGVBQU8scUJBQWtCLEVBQUU7O3lDQUN6QixJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUM7Ozs7Ozs7Q0FDN0MsQ0FBQzs7QUFFRixRQUFRLENBQUMsS0FBSyxHQUFHLG9CQUFnQixFQUFFO01BT3pCLFlBQVk7Ozs7QUFOcEIsVUFBRSxHQUFHLHFCQUFTLEVBQUUsQ0FBQyxDQUFDOzthQUNkLElBQUksQ0FBQyxZQUFZLEVBQUU7Ozs7O2NBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFBOzs7Ozs7eUNBRTFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDOzs7Ozs7O0FBRXZCLG9CQUFZLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUM7O3lDQUM5QixJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDOzs7Ozs7Ozs7O2FBR3BELElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUTs7Ozs7Y0FDSixJQUFJLCtCQUFPLHNCQUFzQixFQUFFOzs7O3lDQUU3QyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQzs7Ozs7OztDQUc3QixDQUFDOztBQUVGLFFBQVEs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LCJmaWxlIjoibGliL2NvbW1hbmRzL2dlc3R1cmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlcnJvcnMgfSBmcm9tICdtb2JpbGUtanNvbi13aXJlLXByb3RvY29sJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyB1bndyYXBFbCB9IGZyb20gJy4uL3V0aWxzJztcblxubGV0IGNvbW1hbmRzID0ge30sIGhlbHBlcnMgPSB7fSwgZXh0ZW5zaW9ucyA9IHt9O1xuY29uc3QgRkxJQ0tfTVMgPSAzMDAwO1xuXG5jb21tYW5kcy5uYXRpdmVUYXAgPSBhc3luYyBmdW5jdGlvbiAoZWwpIHtcbiAgZWwgPSB1bndyYXBFbChlbCk7XG4gIGxldCBjb21tYW5kID0gYGF1LnRhcEJ5SWQoJyR7ZWx9JylgO1xuICBhd2FpdCB0aGlzLnVpQXV0b0NsaWVudC5zZW5kQ29tbWFuZChjb21tYW5kKTtcbn07XG5cbmNvbW1hbmRzLmNsaWNrID0gYXN5bmMgZnVuY3Rpb24gKGVsKSB7XG4gIGVsID0gdW53cmFwRWwoZWwpO1xuICBpZiAodGhpcy5pc1dlYkNvbnRleHQoKSkge1xuICAgIGlmICh0aGlzLm9wdHMubmF0aXZlV2ViVGFwICYmICF0aGlzLmlzUmVhbERldmljZSgpKSB7XG4gICAgICAvLyBhdG9tcy1iYXNlZCBjbGlja3MgZG9uJ3QgYWx3YXlzIHdvcmsgaW4gc2FmYXJpIDdcbiAgICAgIGF3YWl0IHRoaXMubmF0aXZlV2ViVGFwKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGF0b21zRWxlbWVudCA9IHRoaXMudXNlQXRvbXNFbGVtZW50KGVsKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVBdG9tKCdjbGljaycsIFthdG9tc0VsZW1lbnRdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMub3B0cy51c2VSb2JvdCkge1xuICAgICAgLyogVE9ETyAqL3Rocm93IG5ldyBlcnJvcnMuTm90WWV0SW1wbGVtZW50ZWRFcnJvcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCB0aGlzLm5hdGl2ZVRhcChlbCk7XG4gICAgfVxuICB9XG59O1xuXG5jb21tYW5kcy5jbGlja0N1cnJlbnQgPSBhc3luYyBmdW5jdGlvbiAoLypidXR0b24qLykge1xuICBpZiAodGhpcy5pc1dlYkNvbnRleHQoKSkge1xuICAgIGlmIChfLmlzTnVsbCh0aGlzLmN1cldlYkNvb3JkcykpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuVW5rbm93bkVycm9yKCdDYW5ub3QgY2FsbCBjbGljaygpIGJlZm9yZSBjYWxsaW5nIG1vdmVUbygpIHRvIHNldCBjb29yZHMnKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jbGlja1dlYkNvb3JkcygpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmN1ckNvb3JkcyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IGVycm9ycy5Vbmtub3duRXJyb3IoXCJDYW5ub3QgY2FsbCBjbGljaygpIGJlZm9yZSBjYWxsaW5nIG1vdmVUbygpIHRvIHNldCBjb29yZHNcIik7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuY2xpY2tDb29yZHModGhpcy5jdXJDb29yZHMpO1xuICB9XG59O1xuXG5oZWxwZXJzLmNsaWNrQ29vcmRzID0gYXN5bmMgZnVuY3Rpb24gKGNvb3Jkcykge1xuICBpZiAodGhpcy5vcHRzLnVzZVJvYm90KSB7XG4gICAgLyogVE9ETyAqL3Rocm93IG5ldyBlcnJvcnMuTm90WWV0SW1wbGVtZW50ZWRFcnJvcigpO1xuICB9IGVsc2Uge1xuICAgIGxldCBvcHRzID0gY29vcmRzO1xuICAgIG9wdHMudGFwQ291bnQgPSAxO1xuICAgIG9wdHMuZHVyYXRpb24gPSAwLjM7XG4gICAgb3B0cy50b3VjaENvdW50ID0gMTtcbiAgICBsZXQgY29tbWFuZCA9IGBhdS5jb21wbGV4VGFwKCR7SlNPTi5zdHJpbmdpZnkob3B0cyl9KWA7XG4gICAgYXdhaXQgdGhpcy51aUF1dG9DbGllbnQuc2VuZENvbW1hbmQoY29tbWFuZCk7XG4gIH1cbn07XG5cbmNvbW1hbmRzLm1vYmlsZVJvdGF0aW9uID0gYXN5bmMgZnVuY3Rpb24gKHgsIHksIHJhZGl1cywgcm90YXRpb24sIHRvdWNoQ291bnQsIGR1cmF0aW9uLCBlbCkge1xuICBpZiAodGhpcy5pc1dlYkNvbnRleHQoKSkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuTm90WWV0SW1wbGVtZW50ZWRFcnJvcigpO1xuICB9XG4gIGVsID0gdW53cmFwRWwoZWwpO1xuICBsZXQgbG9jYXRpb24gPSB7J3gnIDogeCwgJ3knIDogeX07XG4gIGxldCBvcHRpb25zID0geydkdXJhdGlvbicgOiBkdXJhdGlvbiwgJ3JhZGl1cycgOiByYWRpdXMsICdyb3RhdGlvbicgOiByb3RhdGlvbiwgJ3RvdWNoQ291bnQnIDogdG91Y2hDb3VudH07XG4gIGlmIChlbCkge1xuICAgIGlmICh0aGlzLmlzV2ViQ29udGV4dCgpKSB7XG4gICAgICAvLyBub3QgaW1wbGVtZW50ZWQgeWV0IGluIHRoZSB3ZWJcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuTm90WWV0SW1wbGVtZW50ZWRFcnJvcigpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnVpQXV0b0NsaWVudC5zZW5kQ29tbWFuZChcbiAgICAgIC8vIFVJQUVsZW1lbnQucm90YXRlV2l0aE9wdGlvbnMgdGFrZXMgb25seSBvbmUgb3B0aW9ucyBwYXJhbS5cbiAgICAgIGBhdS5nZXRFbGVtZW50KCcke2VsfScpLnJvdGF0ZVdpdGhPcHRpb25zKCR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucyl9KWApO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IHRoaXMudWlBdXRvQ2xpZW50LnNlbmRDb21tYW5kKFxuICAgICAgYHRhcmdldC5yb3RhdGVXaXRoT3B0aW9ucygke0pTT04uc3RyaW5naWZ5KGxvY2F0aW9uKX0sICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucyl9KWApO1xuICB9XG59O1xuXG5oZWxwZXJzLmhhbmRsZVRhcCA9IGFzeW5jIGZ1bmN0aW9uIChnZXN0dXJlKSB7XG4gIGxldCBvcHRpb25zID0gZ2VzdHVyZS5vcHRpb25zO1xuICBsZXQgY21kQmFzZSA9IG9wdGlvbnMuZWxlbWVudCA/IGBhdS5nZXRFbGVtZW50KCcke29wdGlvbnMuZWxlbWVudH0nKWAgOlxuICAgICdVSUFUYXJnZXQubG9jYWxUYXJnZXQoKS5mcm9udE1vc3RBcHAoKSc7XG5cbiAgLy8gc3RhcnQgYnkgZ2V0dGluZyB0aGUgc2l6ZSBhbmQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgd2UgYXJlIHRhcHBpbmdcbiAgbGV0IHJlY3QgPSBhd2FpdCB0aGlzLnVpQXV0b0NsaWVudC5zZW5kQ29tbWFuZChgJHtjbWRCYXNlfS5yZWN0KClgKTtcblxuICAvLyBkZWZhdWx0IHRvIGNlbnRlclxuICBsZXQgb2Zmc2V0WCA9IDAuNTtcbiAgbGV0IG9mZnNldFkgPSAwLjU7XG5cbiAgbGV0IHNpemUgPSB7dzogcmVjdC5zaXplLndpZHRoLCBoOiByZWN0LnNpemUuaGVpZ2h0fTtcblxuICAvLyBkZWZhdWx0IG9wdGlvbnMgeC95IHRvIGNlbnRlciwgbm8gbWF0dGVyIHRoZSBjb250YWluZXJcbiAgb3B0aW9ucy54ID0gKG9wdGlvbnMueCB8fCAoc2l6ZS53IC8gMikpO1xuICBvcHRpb25zLnkgPSAob3B0aW9ucy55IHx8IChzaXplLmggLyAyKSk7XG5cbiAgb2Zmc2V0WCA9IG9wdGlvbnMueCAvIHNpemUudztcbiAgb2Zmc2V0WSA9IG9wdGlvbnMueSAvIHNpemUuaDtcblxuICBsZXQgb3B0cyA9IHtcbiAgICB0YXBPZmZzZXQ6IHtcbiAgICAgIHg6IG9mZnNldFgsXG4gICAgICB5OiBvZmZzZXRZXG4gICAgfSxcbiAgICB0YXBDb3VudDogb3B0aW9ucy5jb3VudCB8fCAxLFxuICAgIHRvdWNoQ291bnQ6IDFcbiAgfTtcbiAgbGV0IGNtZCA9IGAke2NtZEJhc2V9LnRhcFdpdGhPcHRpb25zKCR7SlNPTi5zdHJpbmdpZnkob3B0cyl9KWA7XG4gIHJldHVybiBhd2FpdCB0aGlzLnVpQXV0b0NsaWVudC5zZW5kQ29tbWFuZChjbWQpO1xufTtcblxuY29tbWFuZHMucGVyZm9ybVRvdWNoID0gYXN5bmMgZnVuY3Rpb24gKGdlc3R1cmVzKSB7XG4gIGlmICh0aGlzLmlzV2ViQ29udGV4dCgpKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5Ob3RZZXRJbXBsZW1lbnRlZEVycm9yKCk7XG4gIH1cblxuICBpZiAoZ2VzdHVyZXMubGVuZ3RoID09PSAxICYmIGdlc3R1cmVzWzBdLmFjdGlvbiA9PT0gJ3RhcCcpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5oYW5kbGVUYXAoZ2VzdHVyZXNbMF0pO1xuICB9XG4gIGxldCB0b3VjaFN0YXRlT2JqZWN0cyA9IGF3YWl0IHRoaXMucGFyc2VUb3VjaChnZXN0dXJlcyk7XG4gIGF3YWl0IHRoaXMudWlBdXRvQ2xpZW50LnNlbmRDb21tYW5kKGB0YXJnZXQudG91Y2goJHtKU09OLnN0cmluZ2lmeSh0b3VjaFN0YXRlT2JqZWN0cyl9KWApO1xufTtcblxuY29tbWFuZHMucGFyc2VUb3VjaCA9IGFzeW5jIGZ1bmN0aW9uIChnZXN0dXJlcykge1xuICAvLyBgcmVsZWFzZWAgaXMgYXV0b21hdGljIGluIGlPU1xuICBpZiAoXy5sYXN0KGdlc3R1cmVzKS5hY3Rpb24gPT09ICdyZWxlYXNlJykge1xuICAgIGdlc3R1cmVzLnBvcCgpO1xuICB9XG5cbiAgbGV0IHRvdWNoU3RhdGVPYmplY3RzID0gW107XG4gIGxldCBmaW5pc2hQYXJzaW5nID0gKCkgPT4ge1xuICAgIGxldCBwcmV2UG9zID0gbnVsbDtcblxuICAgIC8vIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSB0aW1lICh3aGljaCBpcyBub3cgYW4gb2Zmc2V0KVxuICAgIC8vIGFuZCB0aGUgcG9zaXRpb24gKHdoaWNoIG1heSBiZSBhbiBvZmZzZXQpXG4gICAgbGV0IHRpbWUgPSAwO1xuICAgIGZvciAobGV0IHN0YXRlIG9mIHRvdWNoU3RhdGVPYmplY3RzKSB7XG4gICAgICBpZiAoc3RhdGUudG91Y2hbMF0gPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgbm8gcG9zaXRpb24gKHRoaXMgaGFwcGVucyB3aXRoIGB3YWl0YCkgd2UgbmVlZCB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgIHN0YXRlLnRvdWNoWzBdID0gcHJldlBvcztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUudG91Y2hbMF0ub2Zmc2V0ICYmIHByZXZQb3MpIHtcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgYW4gb2Zmc2V0XG4gICAgICAgIHN0YXRlLnRvdWNoWzBdLnggKz0gcHJldlBvcy54O1xuICAgICAgICBzdGF0ZS50b3VjaFswXS55ICs9IHByZXZQb3MueTtcbiAgICAgIH1cbiAgICAgIC8vIHByZXZlbnQgd2FpdCA9PiBwcmVzcyA9PiBtb3ZldG8gY3Jhc2hcbiAgICAgIGlmIChzdGF0ZS50b3VjaFswXSkge1xuICAgICAgICBkZWxldGUgc3RhdGUudG91Y2hbMF0ub2Zmc2V0O1xuICAgICAgICBwcmV2UG9zID0gc3RhdGUudG91Y2hbMF07XG4gICAgICB9XG5cblxuICAgICAgbGV0IHRpbWVPZmZzZXQgPSBzdGF0ZS50aW1lT2Zmc2V0O1xuICAgICAgdGltZSArPSB0aW1lT2Zmc2V0O1xuICAgICAgc3RhdGUudGltZSA9IHRpbWU7XG5cbiAgICAgIGRlbGV0ZSBzdGF0ZS50aW1lT2Zmc2V0O1xuICAgIH1cbiAgfTtcblxuICBsZXQgbmVlZHNQb2ludCA9IChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gXy5pbmNsdWRlcyhbJ3ByZXNzJywgJ21vdmVUbycsICd0YXAnLCAnbG9uZ1ByZXNzJ10sIGFjdGlvbik7XG4gIH07XG5cbiAgbGV0IGN5Y2xlVGhyb3VnaEdlc3R1cmVzID0gYXN5bmMgKCkgPT4ge1xuICAgIGxldCBnZXN0dXJlID0gZ2VzdHVyZXMuc2hpZnQoKTtcbiAgICBpZiAodHlwZW9mIGdlc3R1cmUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBmaW5pc2hQYXJzaW5nKCk7XG4gICAgfVxuICAgIGxldCB0YXBQb2ludCA9IGZhbHNlO1xuXG4gICAgaWYgKG5lZWRzUG9pbnQoZ2VzdHVyZS5hY3Rpb24pKSB7IC8vIHByZXNzLCBsb25nUHJlc3MsIG1vdmVUbyBhbmQgdGFwIGFsbCBuZWVkIGEgcG9zaXRpb25cbiAgICAgIGxldCBlbCA9IGdlc3R1cmUub3B0aW9ucy5lbGVtZW50O1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIGxldCBjb21tYW5kID0gYGF1LmdldEVsZW1lbnQoJyR7ZWx9JykucmVjdCgpYDtcbiAgICAgICAgbGV0IHJlY3QgPSBhd2FpdCB0aGlzLnVpQXV0b0NsaWVudC5zZW5kQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgbGV0IHBvcyA9IHt4OiByZWN0Lm9yaWdpbi54LCB5OiByZWN0Lm9yaWdpbi55fTtcbiAgICAgICAgbGV0IHNpemUgPSB7dzogcmVjdC5zaXplLndpZHRoLCBoOiByZWN0LnNpemUuaGVpZ2h0fTtcblxuICAgICAgICBpZiAoZ2VzdHVyZS5vcHRpb25zLnggfHwgZ2VzdHVyZS5vcHRpb25zLnkpIHtcbiAgICAgICAgICB0YXBQb2ludCA9IHtcbiAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgICAgICB4OiBwb3MueCArIChnZXN0dXJlLm9wdGlvbnMueCB8fCAwKSxcbiAgICAgICAgICAgIHk6IHBvcy55ICsgKGdlc3R1cmUub3B0aW9ucy55IHx8IDApXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXBQb2ludCA9IHtcbiAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgICAgICB4OiBwb3MueCArIChzaXplLncgLyAyKSxcbiAgICAgICAgICAgIHk6IHBvcy55ICsgKHNpemUuaCAvIDIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b3VjaFN0YXRlT2JqZWN0ID0ge1xuICAgICAgICAgIHRpbWVPZmZzZXQ6IDAuMixcbiAgICAgICAgICB0b3VjaDogW1xuICAgICAgICAgICAgdGFwUG9pbnRcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICAgIHRvdWNoU3RhdGVPYmplY3RzLnB1c2godG91Y2hTdGF0ZU9iamVjdCk7XG4gICAgICAgIGF3YWl0IGN5Y2xlVGhyb3VnaEdlc3R1cmVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpT1MgZXhwZWN0cyBhYnNvbHV0ZSBjb29yZGluYXRlcywgc28gd2UgbmVlZCB0byBzYXZlIHRoZXNlIGFzIG9mZnNldHNcbiAgICAgICAgLy8gYW5kIHRoZW4gdHJhbnNsYXRlIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG4gICAgICAgIHRhcFBvaW50ID0ge1xuICAgICAgICAgIG9mZnNldDogdHJ1ZSxcbiAgICAgICAgICB4OiAoZ2VzdHVyZS5vcHRpb25zLnggfHwgMCksXG4gICAgICAgICAgeTogKGdlc3R1cmUub3B0aW9ucy55IHx8IDApXG4gICAgICAgIH07XG4gICAgICAgIGxldCB0b3VjaFN0YXRlT2JqZWN0ID0ge1xuICAgICAgICAgIHRpbWVPZmZzZXQ6IDAuMixcbiAgICAgICAgICB0b3VjaDogW1xuICAgICAgICAgICAgdGFwUG9pbnRcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICAgIHRvdWNoU3RhdGVPYmplY3RzLnB1c2godG91Y2hTdGF0ZU9iamVjdCk7XG4gICAgICAgIGF3YWl0IGN5Y2xlVGhyb3VnaEdlc3R1cmVzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBuZWVkIHRoZSBwcmV2aW91cyBlbnRyeSdzIHRhcCBwb2ludFxuICAgICAgdGFwUG9pbnQgPSBmYWxzZTsgLy8gdGVtcG9yYXJ5IG1hcmtlclxuICAgICAgbGV0IG9mZnNldCA9IDAuMjtcbiAgICAgIGlmIChnZXN0dXJlLmFjdGlvbiA9PT0gJ3dhaXQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2VzdHVyZS5vcHRpb25zLm1zICE9PSAndW5kZWZpbmVkJyB8fCBnZXN0dXJlLm9wdGlvbnMubXMgIT09IG51bGwpIHtcbiAgICAgICAgICBvZmZzZXQgPSAocGFyc2VJbnQoZ2VzdHVyZS5vcHRpb25zLm1zKSAvIDEwMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgdG91Y2hTdGF0ZU9iamVjdCA9IHtcbiAgICAgICAgdGltZU9mZnNldDogb2Zmc2V0LFxuICAgICAgICB0b3VjaDogW1xuICAgICAgICAgIHRhcFBvaW50XG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgICB0b3VjaFN0YXRlT2JqZWN0cy5wdXNoKHRvdWNoU3RhdGVPYmplY3QpO1xuICAgICAgYXdhaXQgY3ljbGVUaHJvdWdoR2VzdHVyZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgYXdhaXQgY3ljbGVUaHJvdWdoR2VzdHVyZXMoKTtcbiAgcmV0dXJuIHRvdWNoU3RhdGVPYmplY3RzO1xufTtcblxubGV0IG1lcmdlU3RhdGVzID0gZnVuY3Rpb24gKHN0YXRlcykge1xuICBsZXQgZ2V0U2xpY2UgPSBmdW5jdGlvbiAoc3RhdGVzLCBpbmRleCkge1xuICAgIGxldCBhcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJheS5wdXNoKHN0YXRlc1tpXVtpbmRleF0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfTtcblxuICBsZXQgdGltZVNlcXVlbmNlID0gZnVuY3Rpb24gKHN0YXRlcykge1xuICAgIGxldCBzZXEgPSBbXTtcbiAgICBfLmVhY2goc3RhdGVzLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGxldCB0aW1lcyA9IF8ubWFwKHN0YXRlLCBcInRpbWVcIik7XG4gICAgICBzZXEgPSBfLnVuaW9uKHNlcSwgdGltZXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlcS5zb3J0KCk7XG4gIH07XG5cbiAgLy8gZm9yIG5vdyB3ZSB3aWxsIGp1c3QgYXNzdW1lIHRoYXQgdGhlIHRpbWVzIGxpbmUgdXBcbiAgbGV0IG1lcmdlZCA9IFtdO1xuICBfLmVhY2godGltZVNlcXVlbmNlKHN0YXRlcyksIGZ1bmN0aW9uICh0aW1lLCBpbmRleCkge1xuICAgIGxldCBzbGljZSA9IGdldFNsaWNlKHN0YXRlcywgaW5kZXgpO1xuICAgIGxldCBvYmogPSB7XG4gICAgICB0aW1lOiB0aW1lLFxuICAgICAgdG91Y2g6IFtdXG4gICAgfTtcbiAgICBfLmVhY2goc2xpY2UsIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIG9iai50b3VjaC5wdXNoKGFjdGlvbi50b3VjaFswXSk7XG4gICAgfSk7XG4gICAgbWVyZ2VkLnB1c2gob2JqKTtcbiAgfSk7XG4gIHJldHVybiBtZXJnZWQ7XG59O1xuXG5jb21tYW5kcy5wZXJmb3JtTXVsdGlBY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAoYWN0aW9ucywgZWwpIHtcbiAgaWYgKHRoaXMuaXNXZWJDb250ZXh0KCkpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLk5vdFlldEltcGxlbWVudGVkRXJyb3IoKTtcbiAgfVxuXG4gIGVsID0gdW53cmFwRWwoZWwpO1xuICAvLyBUT0RPOiB3aHkgZWxlbWVudElkIGlzIG5vdCB1c2VkXG4gIGxldCBzdGF0ZXMgPSBbXTtcbiAgbGV0IGN5Y2xlVGhyb3VnaEFjdGlvbnMgPSBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKTtcblxuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBsZXQgbWVyZ2VkU3RhdGVzID0gbWVyZ2VTdGF0ZXMoc3RhdGVzKTtcbiAgICAgIGF3YWl0IHRoaXMudWlBdXRvQ2xpZW50LnNlbmRDb21tYW5kIChgdGFyZ2V0LnRvdWNoKCR7SlNPTi5zdHJpbmdpZnkobWVyZ2VkU3RhdGVzKX0pYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHZhbCA9IGF3YWl0IHRoaXMucGFyc2VUb3VjaChhY3Rpb24pO1xuICAgIHN0YXRlcy5wdXNoKHZhbCk7XG4gICAgYXdhaXQgY3ljbGVUaHJvdWdoQWN0aW9ucygpO1xuICB9O1xuICBhd2FpdCBjeWNsZVRocm91Z2hBY3Rpb25zKCk7XG59O1xuXG5oZWxwZXJzLm1vYmlsZVNjcm9sbCA9IGFzeW5jIGZ1bmN0aW9uIChvcHRzPXt9KSB7XG4gIGxldCBkaXJlY3Rpb24gPSBvcHRzLmRpcmVjdGlvbjtcbiAgbGV0IGVsID0gb3B0cy5lbGVtZW50O1xuICBlbCA9IHVud3JhcEVsKGVsKTtcbiAgaWYgKHRoaXMuaXNXZWJDb250ZXh0KCkpIHtcbiAgICAvLyBub3QgaW1wbGVtZW50ZWQgeWV0IGluIHdlYlxuICAgIHRocm93IG5ldyBlcnJvcnMuTm90WWV0SW1wbGVtZW50ZWRFcnJvcigpO1xuICB9IGVsc2Uge1xuICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGRpcmVjdGlvbi5zbGljZSgxKTtcbiAgICBsZXQgY29tbWFuZDtcbiAgICBpZiAoXy5pc051bGwoZWwpIHx8IF8uaXNVbmRlZmluZWQoZWwpKSB7XG4gICAgICAvLyBCeSBkZWZhdWx0LCBzY3JvbGwgdGhlIGZpcnN0IHNjcm9sbHZpZXcuXG4gICAgICBjb21tYW5kID0gYGF1LnNjcm9sbEZpcnN0VmlldygnJHtkaXJlY3Rpb259JylgO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBlbGVtZW50IGlzIGRlZmluZWQsIGNhbGwgc2Nyb2xsTGVmdCwgc2Nyb2xsUmlnaHQsIHNjcm9sbFVwLCBhbmQgc2Nyb2xsRG93biBvbiB0aGUgZWxlbWVudC5cbiAgICAgIGNvbW1hbmQgPSBgYXUuZ2V0RWxlbWVudCgnJHtlbH0nKS5zY3JvbGwke2RpcmVjdGlvbn0oKWA7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMudWlBdXRvQ2xpZW50LnNlbmRDb21tYW5kKGNvbW1hbmQpO1xuICB9XG59O1xuXG5jb21tYW5kcy5mbGljayA9IGFzeW5jIGZ1bmN0aW9uIChlbCwgeHNwZWVkLCB5c3BlZWQsIHhvZmZzZXQsIHlvZmZzZXQsIHNwZWVkKSB7XG4gIGVsID0gdW53cmFwRWwoZWwpO1xuICBpZiAoXy5ldmVyeShbZWwsIHhvZmZzZXQsIHlvZmZzZXQsIHNwZWVkXSwgKHApID0+IHtyZXR1cm4gIV8uaXNOdWxsKHApICYmICFfLmlzVW5kZWZpbmVkKHApO30pKSB7XG4gICAgYXdhaXQgdGhpcy5mbGlja0VsZW1lbnQoZWwsIHhvZmZzZXQsIHlvZmZzZXQsIHNwZWVkKTtcbiAgfSBlbHNlIGlmIChfLmV2ZXJ5KFt4c3BlZWQsIHlzcGVlZF0sIChwKSA9PiB7cmV0dXJuICFfLmlzTnVsbChwKSAmJiAhXy5pc1VuZGVmaW5lZChwKTt9KSkge1xuICAgIGF3YWl0IHRoaXMueHlTcGVlZEZsaWNrKHhzcGVlZCwgeXNwZWVkKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlVua25vd25FcnJvcihcbiAgICAgICdCYWQgZmxpY2sgcGFyYW1ldGVycywgcGFzcyBlaXRoZXIgKHhzcGVlZCwgeXNwZWVkKSBvciAoZWxlbWVudCwgeG9mZnNldCwgeW9mZnNldCwgc3BlZWQpIScpO1xuICB9XG59O1xuXG5oZWxwZXJzLnh5U3BlZWRGbGljayA9IGFzeW5jIGZ1bmN0aW9uICh4U3BlZWQsIHlTcGVlZCkge1xuICBsZXQgY29tbWFuZCA9IGBhdS50b3VjaEZsaWNrRnJvbVNwZWVkKCR7eFNwZWVkfSwke3lTcGVlZH0pYDtcbiAgYXdhaXQgQi5hbGwoW1xuICAgIHRoaXMudWlBdXRvQ2xpZW50LnNlbmRDb21tYW5kKGNvbW1hbmQpLFxuICAgIEIuZGVsYXkoRkxJQ0tfTVMpXG4gIF0pO1xufTtcblxuaGVscGVycy5mbGlja0VsZW1lbnQgPSBhc3luYyBmdW5jdGlvbiAoZWwsIHhvZmZzZXQsIHlvZmZzZXQsIHNwZWVkKSB7XG4gIGVsID0gdW53cmFwRWwoZWwpO1xuICBsZXQgY29tbWFuZCA9IFwiXCI7XG4gIGlmICh0aGlzLmlzV2ViQ29udGV4dCgpKSB7XG4gICAgLy8gc3BlZWQgaXMgbm90IHVzZWQgYmVjYXVzZSB1bmRlcmx5aW5nIFVJQVRhcmdldC5mbGlja0Zyb21UbyBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgICBhd2FpdCB0aGlzLndlYkZsaWNrRWxlbWVudChlbCwgeG9mZnNldCwgeW9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgY29tbWFuZCA9IGBhdS5nZXRFbGVtZW50KCcke2VsfScpLnRvdWNoRmxpY2soJHt4b2Zmc2V0fSwke3lvZmZzZXR9LCR7c3BlZWR9KWA7XG4gICAgYXdhaXQgQi5hbGwoW1xuICAgICAgdGhpcy51aUF1dG9DbGllbnQuc2VuZENvbW1hbmQoY29tbWFuZCksXG4gICAgICBCLmRlbGF5KEZMSUNLX01TKVxuICAgIF0pO1xuICB9XG59O1xuXG4vLyBUT0RPOiBtYXliZSByZW5hbWUgdGhpcyBpbiBtanNvbndwXG5jb21tYW5kcy5tb2JpbGVTaGFrZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgYXdhaXQgdGhpcy51aUF1dG9DbGllbnQuc2VuZENvbW1hbmQoXCJhdS5zaGFrZSgpXCIpO1xufTtcblxuY29tbWFuZHMubW92ZVRvID0gYXN5bmMgZnVuY3Rpb24gKGVsLCB4b2Zmc2V0ID0gMCwgeW9mZnNldCA9IDApIHtcbiAgZWwgPSB1bndyYXBFbChlbCk7XG5cbiAgaWYgKHRoaXMuaXNXZWJDb250ZXh0KCkpIHtcbiAgICBsZXQge3gsIHl9ID0gYXdhaXQgdGhpcy5nZXRMb2NhdGlvbihlbCk7XG4gICAgbGV0IGNvb3JkcyA9IHtcbiAgICAgIHg6IHggKyB4b2Zmc2V0LFxuICAgICAgeTogeSArIHlvZmZzZXRcbiAgICB9O1xuICAgIHRoaXMuY3VyV2ViQ29vcmRzID0gY29vcmRzO1xuICAgIGxldCBhdG9tc0VsZW1lbnQgPSB0aGlzLnVzZUF0b21zRWxlbWVudChlbCk7XG4gICAgbGV0IHJlbENvb3JkcyA9IHt4OiB4b2Zmc2V0LCB5OiB5b2Zmc2V0fTtcbiAgICBhd2FpdCB0aGlzLmV4ZWN1dGVBdG9tKCdtb3ZlX21vdXNlJywgW2F0b21zRWxlbWVudCwgcmVsQ29vcmRzXSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKF8uaXNOdWxsKGVsKSB8fCBfLmlzVW5kZWZpbmVkKGVsKSkge1xuICAgICAgaWYgKCF0aGlzLmN1ckNvb3Jkcykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLlVua25vd25FeGNlcHRpb24oXG4gICAgICAgICAgJ0N1cnJlbnQgY3Vyc29yIHBvc2l0aW9uIHVua25vd24sIHBsZWFzZSB1c2UgbW92ZVRvIHdpdGggYW4gZWxlbWVudCB0aGUgZmlyc3QgdGltZS4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VyQ29vcmRzID0ge1xuICAgICAgICB4OiB0aGlzLmN1ckNvb3Jkcy54ICsgeG9mZnNldCxcbiAgICAgICAgeTogdGhpcy5jdXJDb29yZHMueSArIHlvZmZzZXRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlbFBvcyA9IGF3YWl0IHRoaXMuZ2V0TG9jYXRpb24oZWwpO1xuICAgICAgdGhpcy5jdXJDb29yZHMgPSB7XG4gICAgICAgIHg6IGVsUG9zLnggKyB4b2Zmc2V0LFxuICAgICAgICB5OiBlbFBvcy55ICsgeW9mZnNldFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5cbk9iamVjdC5hc3NpZ24oZXh0ZW5zaW9ucywgY29tbWFuZHMsIGhlbHBlcnMpO1xuZXhwb3J0IHsgY29tbWFuZHMsIGhlbHBlcnMgfTtcbmV4cG9ydCBkZWZhdWx0IGV4dGVuc2lvbnM7XG4iXX0=