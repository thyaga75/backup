'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _fs2 = require('fs');

var _fs3 = _interopRequireDefault(_fs2);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumSupport = require('appium-support');

var _teen_process = require('teen_process');

var _admZip = require('adm-zip');

var _admZip2 = _interopRequireDefault(_admZip);

var _request = require('request');

var _request2 = _interopRequireDefault(_request);

var ZIP_EXTS = ['.zip', '.ipa'];

function configureApp(app, appExt) {
  var newApp, shouldUnzipApp;
  return _regeneratorRuntime.async(function configureApp$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!(_lodash2['default'].isNull(app) || _lodash2['default'].isUndefined(app))) {
          context$1$0.next = 2;
          break;
        }

        return context$1$0.abrupt('return');

      case 2:
        newApp = null;
        shouldUnzipApp = _lodash2['default'].includes(ZIP_EXTS, _path2['default'].extname(app));

        if (!((app || '').substring(0, 4).toLowerCase() === 'http')) {
          context$1$0.next = 12;
          break;
        }

        _logger2['default'].info('Using downloadable app \'' + app + '\'');
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(downloadApp(app, shouldUnzipApp ? '.zip' : appExt));

      case 8:
        newApp = context$1$0.sent;

        _logger2['default'].info('Downloaded app to \'' + newApp + '\'');
        context$1$0.next = 18;
        break;

      case 12:
        _logger2['default'].info('Using local app \'' + app + '\'');
        newApp = app;

        if (!shouldUnzipApp) {
          context$1$0.next = 18;
          break;
        }

        context$1$0.next = 17;
        return _regeneratorRuntime.awrap(copyLocalZip(app));

      case 17:
        newApp = context$1$0.sent;

      case 18:
        if (!shouldUnzipApp) {
          context$1$0.next = 23;
          break;
        }

        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(unzipApp(newApp, appExt));

      case 21:
        newApp = context$1$0.sent;

        _logger2['default'].info('Unzipped local app to \'' + newApp + '\'');

      case 23:
        if (!(_path2['default'].extname(newApp) !== appExt)) {
          context$1$0.next = 25;
          break;
        }

        throw new Error('New app path ' + newApp + ' did not have extension ' + appExt);

      case 25:
        return context$1$0.abrupt('return', newApp);

      case 26:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function downloadApp(app, appExt) {
  var appUrl, appPath;
  return _regeneratorRuntime.async(function downloadApp$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        appUrl = undefined;
        context$1$0.prev = 1;

        appUrl = _url2['default'].parse(app);
        context$1$0.next = 8;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](1);
        throw new Error('Invalid App URL (' + app + ')');

      case 8:
        appPath = undefined;
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(downloadFile(_url2['default'].format(appUrl), appExt));

      case 12:
        appPath = context$1$0.sent;
        context$1$0.next = 18;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t1 = context$1$0['catch'](9);
        throw new Error('Problem downloading app from url ' + app + ': ' + context$1$0.t1);

      case 18:
        return context$1$0.abrupt('return', appPath);

      case 19:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 5], [9, 15]]);
}

function downloadFile(sourceUrl, suffix) {
  var targetPath;
  return _regeneratorRuntime.async(function downloadFile$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.path({ prefix: 'appium-app', suffix: suffix }));

      case 2:
        targetPath = context$1$0.sent;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(new _bluebird2['default'](function (resolve, reject) {
          (0, _request2['default'])(sourceUrl).on('error', reject) // handle real errors, like connection errors
          .on('response', function (res) {
            // handle responses that fail, like 404s
            if (res.statusCode >= 400) {
              reject('Error downloading file: ' + res.statusCode);
            }
          }).pipe(_fs3['default'].createWriteStream(targetPath)).on('error', reject).on('close', resolve);
        }));

      case 5:
        _logger2['default'].debug(sourceUrl + ' downloaded to ' + targetPath);
        return context$1$0.abrupt('return', targetPath);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function copyLocalZip(localZipPath) {
  var fileInfo, infile, outfile;
  return _regeneratorRuntime.async(function copyLocalZip$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Copying local zip to tmp dir');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(localZipPath));

      case 3:
        if (context$1$0.sent) {
          context$1$0.next = 5;
          break;
        }

        throw new Error('Local zip did not exist');

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.open({ prefix: 'appium-app', suffix: '.zip' }));

      case 7:
        fileInfo = context$1$0.sent;
        infile = _fs3['default'].createReadStream(localZipPath);
        outfile = _fs3['default'].createWriteStream(fileInfo.path);
        return context$1$0.abrupt('return', new _bluebird2['default'](function (resolve, reject) {
          infile.pipe(outfile).on('close', function () {
            resolve(fileInfo.path);
          }).on('error', function (err) {
            reject(err);
          });
        }));

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function unzipApp(zipPath, appExt) {
  var _ref,
  // first delete any existing apps that might be in our tmp dir
  stdout, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, line, output, relaxedRegStr, strictReg, relaxedReg, strictMatch, relaxedMatch, getAppPath;

  return _regeneratorRuntime.async(function unzipApp$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('find', [_path2['default'].dirname(zipPath), '-type', 'd', '-name', '*' + appExt]));

      case 2:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 7;
        _iterator = _getIterator(stdout.trim().split('\n').filter(Boolean));

      case 9:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 16;
          break;
        }

        line = _step.value;
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(line));

      case 13:
        _iteratorNormalCompletion = true;
        context$1$0.next = 9;
        break;

      case 16:
        context$1$0.next = 22;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t0 = context$1$0['catch'](7);
        _didIteratorError = true;
        _iteratorError = context$1$0.t0;

      case 22:
        context$1$0.prev = 22;
        context$1$0.prev = 23;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 25:
        context$1$0.prev = 25;

        if (!_didIteratorError) {
          context$1$0.next = 28;
          break;
        }

        throw _iteratorError;

      case 28:
        return context$1$0.finish(25);

      case 29:
        return context$1$0.finish(22);

      case 30:
        context$1$0.next = 32;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(_path2['default'].resolve(_path2['default'].dirname(zipPath), 'Payload*')));

      case 32:
        context$1$0.next = 34;
        return _regeneratorRuntime.awrap(unzipFile(zipPath));

      case 34:
        output = context$1$0.sent;
        relaxedRegStr = '(?:creating|inflating|extracting): (.+' + appExt + ')/?';
        strictReg = new RegExp(relaxedRegStr + '$', 'm');
        relaxedReg = new RegExp(relaxedRegStr, 'm');
        strictMatch = strictReg.exec(output);
        relaxedMatch = relaxedReg.exec(output);

        getAppPath = function getAppPath(match) {
          return _path2['default'].resolve(_path2['default'].dirname(zipPath), match[1]);
        };

        if (!strictMatch) {
          context$1$0.next = 43;
          break;
        }

        return context$1$0.abrupt('return', getAppPath(strictMatch));

      case 43:
        if (!relaxedMatch) {
          context$1$0.next = 46;
          break;
        }

        _logger2['default'].debug('Got a relaxed match for app in zip, be careful for app match errors');
        return context$1$0.abrupt('return', getAppPath(relaxedMatch));

      case 46:
        throw new Error('App zip unzipped OK, but we could not find a ' + appExt + ' bundle ' + ('in it. Make sure your archive contains the ' + appExt + ' package ') + 'and nothing else');

      case 47:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 18, 22, 30], [23,, 25, 29]]);
}

function unzipFile(zipPath) {
  var valid, zip, execEnv, execOpts, _ref2, stdout;

  return _regeneratorRuntime.async(function unzipFile$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Unzipping ' + zipPath);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(testZipArchive(zipPath));

      case 3:
        valid = context$1$0.sent;

        if (valid) {
          context$1$0.next = 6;
          break;
        }

        throw new Error('Zip archive ' + zipPath + ' did not test valid');

      case 6:
        if (!_appiumSupport.system.isWindows()) {
          context$1$0.next = 11;
          break;
        }

        zip = new _admZip2['default'](zipPath);

        zip.extractAllTo(_path2['default'].dirname(zipPath), true);
        _logger2['default'].debug('Unzip successful');
        return context$1$0.abrupt('return');

      case 11:
        execEnv = _lodash2['default'].clone(process.env);

        delete execEnv.UNZIP;
        execOpts = { cwd: _path2['default'].dirname(zipPath), env: execEnv };
        context$1$0.prev = 14;
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('unzip', ['-o', zipPath], execOpts));

      case 17:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        return context$1$0.abrupt('return', stdout);

      case 22:
        context$1$0.prev = 22;
        context$1$0.t0 = context$1$0['catch'](14);

        _logger2['default'].error('Unzip threw error ' + context$1$0.t0);
        _logger2['default'].error('Stderr: ' + context$1$0.t0.stderr);
        _logger2['default'].error('Stdout: ' + context$1$0.t0.stdout);
        throw new Error('Archive could not be unzipped, check appium logs.');

      case 28:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[14, 22]]);
}

function testZipArchive(zipPath) {
  var execEnv, execOpts, output;
  return _regeneratorRuntime.async(function testZipArchive$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Testing zip archive: ' + zipPath);

        if (!_appiumSupport.system.isWindows()) {
          context$1$0.next = 11;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(zipPath));

      case 4:
        if (!context$1$0.sent) {
          context$1$0.next = 9;
          break;
        }

        _logger2['default'].debug('Zip archive tested clean');
        return context$1$0.abrupt('return', true);

      case 9:
        _logger2['default'].debug('Zip archive not found');
        return context$1$0.abrupt('return', false);

      case 11:
        execEnv = _lodash2['default'].clone(process.env);

        delete execEnv.UNZIP;
        execOpts = { cwd: _path2['default'].dirname(zipPath), env: execEnv };
        output = undefined;
        context$1$0.prev = 15;
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('unzip', ['-tq', zipPath], execOpts));

      case 18:
        output = context$1$0.sent;

        if (!/No errors detected/.exec(output.stdout)) {
          context$1$0.next = 21;
          break;
        }

        return context$1$0.abrupt('return', true);

      case 21:
        _logger2['default'].error('Zip file ' + zipPath + ' was not valid');
        _logger2['default'].error('Stderr: ' + output.stderr);
        _logger2['default'].error('Stdout: ' + output.stdout);
        _logger2['default'].error('Zip archive did not test successfully, check appium server ' + 'logs for output');
        return context$1$0.abrupt('return', false);

      case 28:
        context$1$0.prev = 28;
        context$1$0.t0 = context$1$0['catch'](15);

        _logger2['default'].error('Test zip archive threw error ' + context$1$0.t0);
        _logger2['default'].error('Stderr: ' + context$1$0.t0.stderr);
        _logger2['default'].error('Stdout: ' + context$1$0.t0.stdout);
        throw new Error('Error testing zip archive, are you sure this is a zip file?');

      case 34:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[15, 28]]);
}

function isPackageOrBundle(app) {
  return (/^([a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+)+$/.test(app)
  );
}

function getCoordDefault(val) {
  // going the long way and checking for undefined and null since
  // we can't be assured `elId` is a string and not an int. Same
  // thing with destElement below.
  return _appiumSupport.util.hasValue(val) ? val : 0.5;
}

function getSwipeTouchDuration(waitGesture) {
  // the touch action api uses ms, we want seconds
  // 0.8 is the default time for the operation
  var duration = 0.8;
  if (typeof waitGesture.options.ms !== 'undefined' && waitGesture.options.ms) {
    duration = waitGesture.options.ms / 1000;
    if (duration === 0) {
      // set to a very low number, since they wanted it fast
      // but below 0.1 becomes 0 steps, which causes errors
      duration = 0.1;
    }
  }
  return duration;
}

exports['default'] = { configureApp: configureApp, downloadApp: downloadApp, downloadFile: downloadFile, copyLocalZip: copyLocalZip,
  unzipApp: unzipApp, unzipFile: unzipFile, testZipArchive: testZipArchive, isPackageOrBundle: isPackageOrBundle,
  getCoordDefault: getCoordDefault, getSwipeTouchDuration: getSwipeTouchDuration };
module.exports = exports['default'];

// immediately shortcircuit if not given an app

// We will be downloading the files to a directory, so make sure it's there
// This step is not required if you have manually created the directory

// don't use request-promise here, we need streams

// now delete any existing zip payload

// in the strict regex, we check for an entry which ends with the
// extension

// otherwise, we allow an entry which contains the extension, but we
// need to be careful, because it might be a false positive
//# sourceMappingURL=data:application/json;base64,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QU0sQ0FBRyxDQUFDO0FBQ3RDLDRCQUFPLEtBQUssY0FBWSxlQUFJLE1BQU0sQ0FBRyxDQUFDO2NBQ2hDLElBQUksS0FBSyxDQUFDLDZEQUE2RCxDQUFDOzs7Ozs7O0NBRWpGOztBQUVELFNBQVMsaUJBQWlCLENBQUUsR0FBRyxFQUFFO0FBQy9CLFNBQU8sQUFBQyx3Q0FBdUMsQ0FBRSxJQUFJLENBQUMsR0FBRyxDQUFDO0lBQUM7Q0FDNUQ7O0FBRUQsU0FBUyxlQUFlLENBQUUsR0FBRyxFQUFFOzs7O0FBSTdCLFNBQU8sb0JBQUssUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7Q0FDdkM7O0FBRUQsU0FBUyxxQkFBcUIsQ0FBRSxXQUFXLEVBQUU7OztBQUczQyxNQUFJLFFBQVEsR0FBRyxHQUFHLENBQUM7QUFDbkIsTUFBSSxPQUFPLFdBQVcsQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLFdBQVcsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRTtBQUMzRSxZQUFRLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDO0FBQ3pDLFFBQUksUUFBUSxLQUFLLENBQUMsRUFBRTs7O0FBR2xCLGNBQVEsR0FBRyxHQUFHLENBQUM7S0FDaEI7R0FDRjtBQUNELFNBQU8sUUFBUSxDQUFDO0NBQ2pCOztxQkFFYyxFQUFFLFlBQVksRUFBWixZQUFZLEVBQUUsV0FBVyxFQUFYLFdBQVcsRUFBRSxZQUFZLEVBQVosWUFBWSxFQUFFLFlBQVksRUFBWixZQUFZO0FBQ3JELFVBQVEsRUFBUixRQUFRLEVBQUUsU0FBUyxFQUFULFNBQVMsRUFBRSxjQUFjLEVBQWQsY0FBYyxFQUFFLGlCQUFpQixFQUFqQixpQkFBaUI7QUFDdEQsaUJBQWUsRUFBZixlQUFlLEVBQUUscUJBQXFCLEVBQXJCLHFCQUFxQixFQUFFIiwiZmlsZSI6ImxpYi9oZWxwZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHVybCBmcm9tICd1cmwnO1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgX2ZzIGZyb20gJ2ZzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IHRlbXBEaXIsIHN5c3RlbSwgZnMsIHV0aWwgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBBZG1aaXAgZnJvbSAnYWRtLXppcCc7XG5pbXBvcnQgcmVxdWVzdCBmcm9tICdyZXF1ZXN0JztcblxuXG5jb25zdCBaSVBfRVhUUyA9IFsnLnppcCcsICcuaXBhJ107XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbmZpZ3VyZUFwcCAoYXBwLCBhcHBFeHQpIHtcbiAgaWYgKF8uaXNOdWxsKGFwcCkgfHwgXy5pc1VuZGVmaW5lZChhcHApKSB7XG4gICAgLy8gaW1tZWRpYXRlbHkgc2hvcnRjaXJjdWl0IGlmIG5vdCBnaXZlbiBhbiBhcHBcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgbmV3QXBwID0gbnVsbDtcbiAgbGV0IHNob3VsZFVuemlwQXBwID0gXy5pbmNsdWRlcyhaSVBfRVhUUywgcGF0aC5leHRuYW1lKGFwcCkpO1xuICBpZiAoKGFwcCB8fCAnJykuc3Vic3RyaW5nKDAsIDQpLnRvTG93ZXJDYXNlKCkgPT09ICdodHRwJykge1xuICAgIGxvZ2dlci5pbmZvKGBVc2luZyBkb3dubG9hZGFibGUgYXBwICcke2FwcH0nYCk7XG4gICAgbmV3QXBwID0gYXdhaXQgZG93bmxvYWRBcHAoYXBwLCBzaG91bGRVbnppcEFwcCA/ICcuemlwJyA6IGFwcEV4dCk7XG4gICAgbG9nZ2VyLmluZm8oYERvd25sb2FkZWQgYXBwIHRvICcke25ld0FwcH0nYCk7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyLmluZm8oYFVzaW5nIGxvY2FsIGFwcCAnJHthcHB9J2ApO1xuICAgIG5ld0FwcCA9IGFwcDtcbiAgICBpZiAoc2hvdWxkVW56aXBBcHApIHtcbiAgICAgIG5ld0FwcCA9IGF3YWl0IGNvcHlMb2NhbFppcChhcHApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzaG91bGRVbnppcEFwcCkge1xuICAgIG5ld0FwcCA9IGF3YWl0IHVuemlwQXBwKG5ld0FwcCwgYXBwRXh0KTtcbiAgICBsb2dnZXIuaW5mbyhgVW56aXBwZWQgbG9jYWwgYXBwIHRvICcke25ld0FwcH0nYCk7XG4gIH1cblxuICBpZiAocGF0aC5leHRuYW1lKG5ld0FwcCkgIT09IGFwcEV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTmV3IGFwcCBwYXRoICR7bmV3QXBwfSBkaWQgbm90IGhhdmUgZXh0ZW5zaW9uICR7YXBwRXh0fWApO1xuICB9XG5cbiAgcmV0dXJuIG5ld0FwcDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRBcHAgKGFwcCwgYXBwRXh0KSB7XG4gIGxldCBhcHBVcmw7XG4gIHRyeSB7XG4gICAgYXBwVXJsID0gdXJsLnBhcnNlKGFwcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBBcHAgVVJMICgke2FwcH0pYCk7XG4gIH1cblxuICBsZXQgYXBwUGF0aDtcbiAgdHJ5IHtcbiAgICBhcHBQYXRoID0gYXdhaXQgZG93bmxvYWRGaWxlKHVybC5mb3JtYXQoYXBwVXJsKSwgYXBwRXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ibGVtIGRvd25sb2FkaW5nIGFwcCBmcm9tIHVybCAke2FwcH06ICR7ZXJyfWApO1xuICB9XG5cbiAgcmV0dXJuIGFwcFBhdGg7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkRmlsZSAoc291cmNlVXJsLCBzdWZmaXgpIHtcbiAgLy8gV2Ugd2lsbCBiZSBkb3dubG9hZGluZyB0aGUgZmlsZXMgdG8gYSBkaXJlY3RvcnksIHNvIG1ha2Ugc3VyZSBpdCdzIHRoZXJlXG4gIC8vIFRoaXMgc3RlcCBpcyBub3QgcmVxdWlyZWQgaWYgeW91IGhhdmUgbWFudWFsbHkgY3JlYXRlZCB0aGUgZGlyZWN0b3J5XG4gIGxldCB0YXJnZXRQYXRoID0gYXdhaXQgdGVtcERpci5wYXRoKHtwcmVmaXg6ICdhcHBpdW0tYXBwJywgc3VmZml4OiBzdWZmaXh9KTtcblxuICAvLyBkb24ndCB1c2UgcmVxdWVzdC1wcm9taXNlIGhlcmUsIHdlIG5lZWQgc3RyZWFtc1xuICBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVxdWVzdChzb3VyY2VVcmwpXG4gICAgICAub24oJ2Vycm9yJywgcmVqZWN0KSAvLyBoYW5kbGUgcmVhbCBlcnJvcnMsIGxpa2UgY29ubmVjdGlvbiBlcnJvcnNcbiAgICAgIC5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIC8vIGhhbmRsZSByZXNwb25zZXMgdGhhdCBmYWlsLCBsaWtlIDQwNHNcbiAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgIHJlamVjdChgRXJyb3IgZG93bmxvYWRpbmcgZmlsZTogJHtyZXMuc3RhdHVzQ29kZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5waXBlKF9mcy5jcmVhdGVXcml0ZVN0cmVhbSh0YXJnZXRQYXRoKSlcbiAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAub24oJ2Nsb3NlJywgcmVzb2x2ZSk7XG4gIH0pO1xuICBsb2dnZXIuZGVidWcoYCR7c291cmNlVXJsfSBkb3dubG9hZGVkIHRvICR7dGFyZ2V0UGF0aH1gKTtcbiAgcmV0dXJuIHRhcmdldFBhdGg7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvcHlMb2NhbFppcCAobG9jYWxaaXBQYXRoKSB7XG4gIGxvZ2dlci5kZWJ1ZygnQ29weWluZyBsb2NhbCB6aXAgdG8gdG1wIGRpcicpO1xuICBpZiAoIShhd2FpdCBmcy5leGlzdHMobG9jYWxaaXBQYXRoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsIHppcCBkaWQgbm90IGV4aXN0Jyk7XG4gIH1cbiAgbGV0IGZpbGVJbmZvID0gYXdhaXQgdGVtcERpci5vcGVuKHtwcmVmaXg6ICdhcHBpdW0tYXBwJywgc3VmZml4OiAnLnppcCd9KTtcbiAgbGV0IGluZmlsZSA9IF9mcy5jcmVhdGVSZWFkU3RyZWFtKGxvY2FsWmlwUGF0aCk7XG4gIGxldCBvdXRmaWxlID0gX2ZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZpbGVJbmZvLnBhdGgpO1xuICByZXR1cm4gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGluZmlsZS5waXBlKG91dGZpbGUpLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIHJlc29sdmUoZmlsZUluZm8ucGF0aCk7XG4gICAgfSkub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiB1bnppcEFwcCAoemlwUGF0aCwgYXBwRXh0KSB7XG4gIC8vIGZpcnN0IGRlbGV0ZSBhbnkgZXhpc3RpbmcgYXBwcyB0aGF0IG1pZ2h0IGJlIGluIG91ciB0bXAgZGlyXG4gIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ2ZpbmQnLCBbcGF0aC5kaXJuYW1lKHppcFBhdGgpLCAnLXR5cGUnLCAnZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy1uYW1lJywgYCoke2FwcEV4dH1gXSk7XG4gIGZvciAobGV0IGxpbmUgb2Ygc3Rkb3V0LnRyaW0oKS5zcGxpdCgnXFxuJykuZmlsdGVyKEJvb2xlYW4pKSB7XG4gICAgYXdhaXQgZnMucmltcmFmKGxpbmUpO1xuICB9XG4gIC8vIG5vdyBkZWxldGUgYW55IGV4aXN0aW5nIHppcCBwYXlsb2FkXG4gIGF3YWl0IGZzLnJpbXJhZihwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKHppcFBhdGgpLCAnUGF5bG9hZConKSk7XG4gIGxldCBvdXRwdXQgPSBhd2FpdCB1bnppcEZpbGUoemlwUGF0aCk7XG4gIGxldCByZWxheGVkUmVnU3RyID0gYCg/OmNyZWF0aW5nfGluZmxhdGluZ3xleHRyYWN0aW5nKTogKC4rJHthcHBFeHR9KS8/YDtcbiAgLy8gaW4gdGhlIHN0cmljdCByZWdleCwgd2UgY2hlY2sgZm9yIGFuIGVudHJ5IHdoaWNoIGVuZHMgd2l0aCB0aGVcbiAgLy8gZXh0ZW5zaW9uXG4gIGxldCBzdHJpY3RSZWcgPSBuZXcgUmVnRXhwKGAke3JlbGF4ZWRSZWdTdHJ9JGAsICdtJyk7XG4gIC8vIG90aGVyd2lzZSwgd2UgYWxsb3cgYW4gZW50cnkgd2hpY2ggY29udGFpbnMgdGhlIGV4dGVuc2lvbiwgYnV0IHdlXG4gIC8vIG5lZWQgdG8gYmUgY2FyZWZ1bCwgYmVjYXVzZSBpdCBtaWdodCBiZSBhIGZhbHNlIHBvc2l0aXZlXG4gIGxldCByZWxheGVkUmVnID0gbmV3IFJlZ0V4cChyZWxheGVkUmVnU3RyLCAnbScpO1xuICBsZXQgc3RyaWN0TWF0Y2ggPSBzdHJpY3RSZWcuZXhlYyhvdXRwdXQpO1xuICBsZXQgcmVsYXhlZE1hdGNoID0gcmVsYXhlZFJlZy5leGVjKG91dHB1dCk7XG4gIGxldCBnZXRBcHBQYXRoID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoemlwUGF0aCksIG1hdGNoWzFdKTtcbiAgfTtcblxuICBpZiAoc3RyaWN0TWF0Y2gpIHtcbiAgICByZXR1cm4gZ2V0QXBwUGF0aChzdHJpY3RNYXRjaCk7XG4gIH1cblxuICBpZiAocmVsYXhlZE1hdGNoKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdHb3QgYSByZWxheGVkIG1hdGNoIGZvciBhcHAgaW4gemlwLCBiZSBjYXJlZnVsIGZvciBhcHAgbWF0Y2ggZXJyb3JzJyk7XG4gICAgcmV0dXJuIGdldEFwcFBhdGgocmVsYXhlZE1hdGNoKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihgQXBwIHppcCB1bnppcHBlZCBPSywgYnV0IHdlIGNvdWxkIG5vdCBmaW5kIGEgJHthcHBFeHR9IGJ1bmRsZSBgICtcbiAgICAgICAgICAgICAgICAgIGBpbiBpdC4gTWFrZSBzdXJlIHlvdXIgYXJjaGl2ZSBjb250YWlucyB0aGUgJHthcHBFeHR9IHBhY2thZ2UgYCArXG4gICAgICAgICAgICAgICAgICBgYW5kIG5vdGhpbmcgZWxzZWApO1xufVxuXG5hc3luYyBmdW5jdGlvbiB1bnppcEZpbGUgKHppcFBhdGgpIHtcbiAgbG9nZ2VyLmRlYnVnKGBVbnppcHBpbmcgJHt6aXBQYXRofWApO1xuICBsZXQgdmFsaWQgPSBhd2FpdCB0ZXN0WmlwQXJjaGl2ZSh6aXBQYXRoKTtcbiAgaWYgKCF2YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgWmlwIGFyY2hpdmUgJHt6aXBQYXRofSBkaWQgbm90IHRlc3QgdmFsaWRgKTtcbiAgfVxuXG4gIGlmIChzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICBsZXQgemlwID0gbmV3IEFkbVppcCh6aXBQYXRoKTtcbiAgICB6aXAuZXh0cmFjdEFsbFRvKHBhdGguZGlybmFtZSh6aXBQYXRoKSwgdHJ1ZSk7XG4gICAgbG9nZ2VyLmRlYnVnKCdVbnppcCBzdWNjZXNzZnVsJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGV4ZWNFbnYgPSBfLmNsb25lKHByb2Nlc3MuZW52KTtcbiAgZGVsZXRlIGV4ZWNFbnYuVU5aSVA7XG4gIGxldCBleGVjT3B0cyA9IHtjd2Q6IHBhdGguZGlybmFtZSh6aXBQYXRoKSwgZW52OiBleGVjRW52fTtcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKCd1bnppcCcsIFsnLW8nLCB6aXBQYXRoXSwgZXhlY09wdHMpO1xuICAgIHJldHVybiBzdGRvdXQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZ2dlci5lcnJvcihgVW56aXAgdGhyZXcgZXJyb3IgJHtlcnJ9YCk7XG4gICAgbG9nZ2VyLmVycm9yKGBTdGRlcnI6ICR7ZXJyLnN0ZGVycn1gKTtcbiAgICBsb2dnZXIuZXJyb3IoYFN0ZG91dDogJHtlcnIuc3Rkb3V0fWApO1xuICAgIHRocm93IG5ldyBFcnJvcignQXJjaGl2ZSBjb3VsZCBub3QgYmUgdW56aXBwZWQsIGNoZWNrIGFwcGl1bSBsb2dzLicpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRlc3RaaXBBcmNoaXZlICh6aXBQYXRoKSB7XG4gIGxvZ2dlci5kZWJ1ZyhgVGVzdGluZyB6aXAgYXJjaGl2ZTogJHt6aXBQYXRofWApO1xuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgaWYgKGF3YWl0IGZzLmV4aXN0cyh6aXBQYXRoKSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdaaXAgYXJjaGl2ZSB0ZXN0ZWQgY2xlYW4nKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1ppcCBhcmNoaXZlIG5vdCBmb3VuZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGxldCBleGVjRW52ID0gXy5jbG9uZShwcm9jZXNzLmVudik7XG4gIGRlbGV0ZSBleGVjRW52LlVOWklQO1xuICBsZXQgZXhlY09wdHMgPSB7Y3dkOiBwYXRoLmRpcm5hbWUoemlwUGF0aCksIGVudjogZXhlY0Vudn07XG4gIGxldCBvdXRwdXQ7XG4gIHRyeSB7XG4gICAgb3V0cHV0ID0gYXdhaXQgZXhlYygndW56aXAnLCBbJy10cScsIHppcFBhdGhdLCBleGVjT3B0cyk7XG4gICAgaWYgKC9ObyBlcnJvcnMgZGV0ZWN0ZWQvLmV4ZWMob3V0cHV0LnN0ZG91dCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsb2dnZXIuZXJyb3IoYFppcCBmaWxlICR7emlwUGF0aH0gd2FzIG5vdCB2YWxpZGApO1xuICAgIGxvZ2dlci5lcnJvcihgU3RkZXJyOiAke291dHB1dC5zdGRlcnJ9YCk7XG4gICAgbG9nZ2VyLmVycm9yKGBTdGRvdXQ6ICR7b3V0cHV0LnN0ZG91dH1gKTtcbiAgICBsb2dnZXIuZXJyb3IoJ1ppcCBhcmNoaXZlIGRpZCBub3QgdGVzdCBzdWNjZXNzZnVsbHksIGNoZWNrIGFwcGl1bSBzZXJ2ZXIgJyArXG4gICAgICAgICAgICAgICAgICdsb2dzIGZvciBvdXRwdXQnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZ2dlci5lcnJvcihgVGVzdCB6aXAgYXJjaGl2ZSB0aHJldyBlcnJvciAke2Vycn1gKTtcbiAgICBsb2dnZXIuZXJyb3IoYFN0ZGVycjogJHtlcnIuc3RkZXJyfWApO1xuICAgIGxvZ2dlci5lcnJvcihgU3Rkb3V0OiAke2Vyci5zdGRvdXR9YCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0ZXN0aW5nIHppcCBhcmNoaXZlLCBhcmUgeW91IHN1cmUgdGhpcyBpcyBhIHppcCBmaWxlPycpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzUGFja2FnZU9yQnVuZGxlIChhcHApIHtcbiAgcmV0dXJuICgvXihbYS16QS1aMC05XFwtX10rXFwuW2EtekEtWjAtOVxcLV9dKykrJC8pLnRlc3QoYXBwKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29vcmREZWZhdWx0ICh2YWwpIHtcbiAgLy8gZ29pbmcgdGhlIGxvbmcgd2F5IGFuZCBjaGVja2luZyBmb3IgdW5kZWZpbmVkIGFuZCBudWxsIHNpbmNlXG4gIC8vIHdlIGNhbid0IGJlIGFzc3VyZWQgYGVsSWRgIGlzIGEgc3RyaW5nIGFuZCBub3QgYW4gaW50LiBTYW1lXG4gIC8vIHRoaW5nIHdpdGggZGVzdEVsZW1lbnQgYmVsb3cuXG4gIHJldHVybiB1dGlsLmhhc1ZhbHVlKHZhbCkgPyB2YWwgOiAwLjU7XG59XG5cbmZ1bmN0aW9uIGdldFN3aXBlVG91Y2hEdXJhdGlvbiAod2FpdEdlc3R1cmUpIHtcbiAgLy8gdGhlIHRvdWNoIGFjdGlvbiBhcGkgdXNlcyBtcywgd2Ugd2FudCBzZWNvbmRzXG4gIC8vIDAuOCBpcyB0aGUgZGVmYXVsdCB0aW1lIGZvciB0aGUgb3BlcmF0aW9uXG4gIGxldCBkdXJhdGlvbiA9IDAuODtcbiAgaWYgKHR5cGVvZiB3YWl0R2VzdHVyZS5vcHRpb25zLm1zICE9PSAndW5kZWZpbmVkJyAmJiB3YWl0R2VzdHVyZS5vcHRpb25zLm1zKSB7XG4gICAgZHVyYXRpb24gPSB3YWl0R2VzdHVyZS5vcHRpb25zLm1zIC8gMTAwMDtcbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIC8vIHNldCB0byBhIHZlcnkgbG93IG51bWJlciwgc2luY2UgdGhleSB3YW50ZWQgaXQgZmFzdFxuICAgICAgLy8gYnV0IGJlbG93IDAuMSBiZWNvbWVzIDAgc3RlcHMsIHdoaWNoIGNhdXNlcyBlcnJvcnNcbiAgICAgIGR1cmF0aW9uID0gMC4xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHVyYXRpb247XG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgY29uZmlndXJlQXBwLCBkb3dubG9hZEFwcCwgZG93bmxvYWRGaWxlLCBjb3B5TG9jYWxaaXAsXG4gICAgICAgICAgICAgICAgIHVuemlwQXBwLCB1bnppcEZpbGUsIHRlc3RaaXBBcmNoaXZlLCBpc1BhY2thZ2VPckJ1bmRsZSxcbiAgICAgICAgICAgICAgICAgZ2V0Q29vcmREZWZhdWx0LCBnZXRTd2lwZVRvdWNoRHVyYXRpb24gfTtcbiJdfQ==