'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bplistCreator = require('bplist-creator');

var _bplistCreator2 = _interopRequireDefault(_bplistCreator);

var _bplistParser = require('bplist-parser');

var _bplistParser2 = _interopRequireDefault(_bplistParser);

var _bufferpack = require('bufferpack');

var _bufferpack2 = _interopRequireDefault(_bufferpack);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _remoteDebugger = require('./remote-debugger');

var _nodeUuid = require('node-uuid');

var _nodeUuid2 = _interopRequireDefault(_nodeUuid);

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _remoteDebuggerMessageHandler = require('./remote-debugger-message-handler');

var _remoteDebuggerMessageHandler2 = _interopRequireDefault(_remoteDebuggerMessageHandler);

var _remoteMessages = require('./remote-messages');

var _remoteMessages2 = _interopRequireDefault(_remoteMessages);

var RemoteDebuggerRpcClient = (function () {
  function RemoteDebuggerRpcClient(host) {
    var port = arguments.length <= 1 || arguments[1] === undefined ? _remoteDebugger.REMOTE_DEBUGGER_PORT : arguments[1];
    var specialMessageHandlers = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, RemoteDebuggerRpcClient);

    // socket and connection configuration
    this.socket = null;
    this.host = host;
    this.port = port;
    this.connected = false;
    this.connId = _nodeUuid2['default'].v4();
    this.senderId = _nodeUuid2['default'].v4();
    this.curMsgId = 0;
    this.received = new Buffer(0);
    this.readPos = 0;

    // message handlers
    this.specialMessageHandlers = specialMessageHandlers;
    this.messageHandler = null;
  }

  _createClass(RemoteDebuggerRpcClient, [{
    key: 'connect',
    value: function connect() {
      return _regeneratorRuntime.async(function connect$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.messageHandler = new _remoteDebuggerMessageHandler2['default'](this.specialMessageHandlers);

            // create socket and handle its messages
            this.socket = new _net2['default'].Socket({ type: 'tcp6' });
            this.socket.setNoDelay(true);
            this.socket.on('close', function () {
              if (_this.connected) {
                _logger2['default'].debug('Debugger socket disconnected');
              }
              _this.connected = false;
              _this.socket = null;
            });
            this.socket.on('end', function () {
              _this.connected = false;
            });
            this.socket.on('data', this.receive.bind(this));

            // connect the socket
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(new _bluebird2['default'](function callee$2$0(resolve, reject) {
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                var _this2 = this;

                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    // only resolve this function when we are actually connected
                    this.socket.connect(this.port, '::1');
                    this.socket.on('connect', function callee$3$0() {
                      return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                        while (1) switch (context$4$0.prev = context$4$0.next) {
                          case 0:
                            _logger2['default'].debug('Debugger socket connected to ' + this.socket.remoteAddress + ':' + this.socket.remotePort);
                            this.connected = true;

                            resolve();

                          case 3:
                          case 'end':
                            return context$4$0.stop();
                        }
                      }, null, _this2);
                    });
                    this.socket.on('error', function (exception) {
                      if (_this2.connected) {
                        _logger2['default'].error('Socket error: ' + exception.message);
                        _this2.connected = false;
                      }

                      // the connection was refused, so reject the connect promise
                      reject(exception);
                    });

                  case 3:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this);
            }));

          case 8:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      return _regeneratorRuntime.async(function disconnect$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.isConnected()) {
              _logger2['default'].debug('Disconnecting from remote debugger');
              this.socket.destroy();
            }
            this.connected = false;

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'isConnected',
    value: function isConnected() {
      return this.connected;
    }
  }, {
    key: 'setSpecialMessageHandler',
    value: function setSpecialMessageHandler(key, errorHandler, handler) {
      this.messageHandler.setSpecialMessageHandler(key, errorHandler, handler);
    }
  }, {
    key: 'setDataMessageHandler',
    value: function setDataMessageHandler(key, errorHandler, handler) {
      this.messageHandler.setDataMessageHandler(key, errorHandler, handler);
    }
  }, {
    key: 'allowNavigationWithoutReload',
    value: function allowNavigationWithoutReload() {
      var allow = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      this.messageHandler.allowNavigationWithoutReload(allow);
    }
  }, {
    key: 'selectApp',
    value: function selectApp(appIdKey, applicationConnectedHandler) {
      return _regeneratorRuntime.async(function selectApp$(context$2$0) {
        var _this4 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(new _bluebird2['default'](function callee$2$0(resolve, reject) {
              var onAppChange, _ref, _ref2, connectedAppIdKey, pageDict, msg;

              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                var _this3 = this;

                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    onAppChange = function onAppChange(dict) {
                      var oldAppIdKey, correctAppIdKey;
                      return _regeneratorRuntime.async(function onAppChange$(context$4$0) {
                        while (1) switch (context$4$0.prev = context$4$0.next) {
                          case 0:
                            oldAppIdKey = dict.WIRHostApplicationIdentifierKey;
                            correctAppIdKey = dict.WIRApplicationIdentifierKey;

                            // if this is a report of a proxy redirect from the remote debugger
                            // we want to update our dictionary and get a new app id
                            if (oldAppIdKey && correctAppIdKey !== oldAppIdKey) {
                              _logger2['default'].debug('We were notified we might have connected to the wrong app. ' + ('Using id ' + correctAppIdKey + ' instead of ' + oldAppIdKey));
                            }

                            applicationConnectedHandler(dict);
                            reject();

                          case 5:
                          case 'end':
                            return context$4$0.stop();
                        }
                      }, null, _this3);
                    };

                    this.setSpecialMessageHandler('_rpc_applicationConnected:', reject, onAppChange);

                    // do the actual connecting to the app
                    context$3$0.next = 4;
                    return _regeneratorRuntime.awrap(this.send('connectToApp', {
                      appIdKey: appIdKey
                    }));

                  case 4:
                    _ref = context$3$0.sent;
                    _ref2 = _slicedToArray(_ref, 2);
                    connectedAppIdKey = _ref2[0];
                    pageDict = _ref2[1];

                    // sometimes the connect logic happens, but with an empty dictionary
                    // which leads to the remote debugger getting disconnected, and into a loop
                    if (_lodash2['default'].isEmpty(pageDict)) {
                      msg = 'Empty page dictionary received';

                      _logger2['default'].debug(msg);
                      reject(new Error(msg));
                    } else {
                      resolve([connectedAppIdKey, pageDict]);
                    }

                  case 9:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this4);
            })['finally'](function () {
              // no matter what, we want to restore the handler that was changed.
              _this4.setSpecialMessageHandler('_rpc_applicationConnected:', null, applicationConnectedHandler);
            }));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'send',
    value: function send(command) {
      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      return _regeneratorRuntime.async(function send$(context$2$0) {
        var _this6 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(new _bluebird2['default'](function callee$2$0(resolve, reject) {
              var data, socketCb, onSocketError, plist, msg;
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                var _this5 = this;

                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    // promise to be resolved whenever remote debugger
                    // replies to our request

                    // retrieve the correct command to send
                    opts = _lodash2['default'].defaults({ connId: this.connId, senderId: this.senderId }, opts);
                    data = (0, _remoteMessages2['default'])(command, opts);
                    socketCb = _lodash2['default'].noop;

                    onSocketError = function onSocketError(exception) {
                      if (_this5.connected) {
                        _logger2['default'].error('Socket error: ' + exception.message);
                      }

                      // the connection was refused, so reject the connect promise
                      reject(exception);

                      // remove this listener, so we don't exhaust the system
                      _this5.socket.removeListener('error', onSocketError);
                    };

                    this.socket.on('error', onSocketError);
                    if (this.messageHandler.hasSpecialMessageHandler(data.__selector)) {
                      // special replies will return any number of arguments
                      this.setSpecialMessageHandler(data.__selector, reject, (function () {
                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                          args[_key] = arguments[_key];
                        }

                        _logger2['default'].debug('Received response from socket send: \'' + _lodash2['default'].truncate(JSON.stringify(args), 50) + '\'');
                        this.socket.removeListener('error', onSocketError);
                        resolve(args);
                      }).bind(this));
                    } else if (data.__argument && data.__argument.WIRSocketDataKey) {
                      // keep track of the messages coming and going using
                      // a simple sequential id
                      this.curMsgId++;
                      this.setDataMessageHandler(this.curMsgId.toString(), reject, function (value) {
                        _logger2['default'].debug('Received data response from socket send: \'' + _lodash2['default'].truncate(JSON.stringify(value), 50) + '\'');
                        _logger2['default'].debug('Original command: ' + command);
                        _this5.socket.removeListener('error', onSocketError);
                        resolve(value);
                      });
                      data.__argument.WIRSocketDataKey.id = this.curMsgId;
                      data.__argument.WIRSocketDataKey = new Buffer(JSON.stringify(data.__argument.WIRSocketDataKey));
                    } else {
                      // we want to immediately resolve this socket.write
                      // any long term callbacks will do their business in the background
                      socketCb = function () {
                        _this5.socket.removeListener('error', onSocketError);
                        resolve();
                      };
                    }

                    _logger2['default'].debug('Sending \'' + data.__selector + '\' message to remote debugger');

                    // remote debugger expects a binary plist as data
                    plist = undefined;
                    context$3$0.prev = 8;

                    plist = (0, _bplistCreator2['default'])(data);
                    context$3$0.next = 17;
                    break;

                  case 12:
                    context$3$0.prev = 12;
                    context$3$0.t0 = context$3$0['catch'](8);
                    msg = 'Could not create binary plist from data: ' + context$3$0.t0.message;

                    _logger2['default'].error(msg);
                    return context$3$0.abrupt('return', reject(new Error(msg)));

                  case 17:

                    if (this.socket && this.connected) {
                      // cork and uncork in order to not buffer the write
                      // on some systems this is necessary or the server
                      // gets confused.
                      this.socket.cork();
                      this.socket.write(_bufferpack2['default'].pack('L', [plist.length]));
                      this.socket.write(plist, socketCb);
                      this.socket.uncork();
                    } else {
                      msg = 'Attempted to write data to socket after it was closed!';

                      _logger2['default'].error(msg);
                      reject(new Error(msg));
                    }

                  case 18:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this6, [[8, 12]]);
            }));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'receive',
    value: function receive(data) {
      // Append this new data to the existing Buffer
      this.received = Buffer.concat([this.received, data]);
      var dataLeftOver = true;

      // Parse multiple messages in the same packet
      while (dataLeftOver) {
        // Store a reference to where we were
        var oldReadPos = this.readPos;

        // Read the prefix (plist length) to see how far to read next
        // It's always 4 bytes long
        var prefix = this.received.slice(this.readPos, this.readPos + 4);

        var msgLength = undefined;
        try {
          msgLength = _bufferpack2['default'].unpack('L', prefix)[0];
        } catch (e) {
          _logger2['default'].error('Buffer could not unpack: ' + e);
          return;
        }

        // Jump forward 4 bytes
        this.readPos += 4;

        // Is there enough data here?
        // If not, jump back to our original position and gtfo
        if (this.received.length < msgLength + this.readPos) {
          this.readPos = oldReadPos;
          break;
        }

        // Extract the main body of the message (where the plist should be)
        var body = this.received.slice(this.readPos, msgLength + this.readPos);

        // Extract the plist
        var plist = undefined;
        try {
          plist = _bplistParser2['default'].parseBuffer(body);
        } catch (e) {
          _logger2['default'].error('Error parsing binary plist: ' + e);
          return;
        }

        // bplistParse.parseBuffer returns an array
        if (plist.length === 1) {
          plist = plist[0];
        }

        var _arr = ['WIRMessageDataKey', 'WIRDestinationKey', 'WIRSocketDataKey'];
        for (var _i = 0; _i < _arr.length; _i++) {
          var key = _arr[_i];
          if (!_lodash2['default'].isUndefined(plist[key])) {
            plist[key] = plist[key].toString("utf8");
          }
        }

        if (plist.__selector === "_rpc_applicationSentData:") {
          _logger2['default'].debug('Received applicationSentData response');
        } else {
          _logger2['default'].debug('Receiving data from remote debugger: \'' + JSON.stringify(plist) + '\'');
        }

        // Jump forward the length of the plist
        this.readPos += msgLength;

        // Calculate how much buffer is left
        var leftOver = this.received.length - this.readPos;

        // Is there some left over?
        if (leftOver !== 0) {
          // Copy what's left over into a new buffer, and save it for next time
          var chunk = new Buffer(leftOver);
          this.received.copy(chunk, 0, this.readPos);
          this.received = chunk;
        } else {
          // Otherwise, empty the buffer and get out of the loop
          this.received = new Buffer(0);
          dataLeftOver = false;
        }

        // Reset the read position
        this.readPos = 0;

        // Now do something with the plist
        if (plist) {
          this.messageHandler.handleMessage(plist);
        }
      }
    }
  }, {
    key: 'setTimelineEventHandler',
    value: function setTimelineEventHandler(timelineEventHandler) {
      this.timelineEventHandler = timelineEventHandler;
      this.messageHandler.setTimelineEventHandler(timelineEventHandler);
    }
  }]);

  return RemoteDebuggerRpcClient;
})();

exports['default'] = RemoteDebuggerRpcClient;
module.exports = exports['default'];

// local callback, temporarily added as callback to
// `_rpc_applicationConnected:` remote debugger response
// to handle the initial connection

// from the dictionary returned, get the ids

// most of the time we don't care when socket.write does
// so give it an empty function

// handle socket problems
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9yZW1vdGUtZGVidWdnZXItcnBjLWNsaWVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O3NCQUFnQixVQUFVOzs7O3NCQUNaLFFBQVE7Ozs7NkJBQ0csZ0JBQWdCOzs7OzRCQUNqQixlQUFlOzs7OzBCQUNoQixZQUFZOzs7O3dCQUNmLFVBQVU7Ozs7OEJBQ08sbUJBQW1COzt3QkFDdkMsV0FBVzs7OzttQkFDWixLQUFLOzs7OzRDQUNTLG1DQUFtQzs7Ozs4QkFDcEMsbUJBQW1COzs7O0lBRzNCLHVCQUF1QjtBQUM5QixXQURPLHVCQUF1QixDQUM3QixJQUFJLEVBQTREO1FBQTFELElBQUk7UUFBeUIsc0JBQXNCLHlEQUFHLEVBQUU7OzBCQUR4RCx1QkFBdUI7OztBQUd4QyxRQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztBQUNuQixRQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNqQixRQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNqQixRQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztBQUN2QixRQUFJLENBQUMsTUFBTSxHQUFHLHNCQUFLLEVBQUUsRUFBRSxDQUFDO0FBQ3hCLFFBQUksQ0FBQyxRQUFRLEdBQUcsc0JBQUssRUFBRSxFQUFFLENBQUM7QUFDMUIsUUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFDbEIsUUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5QixRQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQzs7O0FBR2pCLFFBQUksQ0FBQyxzQkFBc0IsR0FBRyxzQkFBc0IsQ0FBQztBQUNyRCxRQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQztHQUM1Qjs7ZUFoQmtCLHVCQUF1Qjs7V0FrQjVCOzs7Ozs7QUFDWixnQkFBSSxDQUFDLGNBQWMsR0FBRyw4Q0FBc0IsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENB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RTs7O1NBM1NrQix1QkFBdUI7OztxQkFBdkIsdUJBQXVCIiwiZmlsZSI6ImxpYi9yZW1vdGUtZGVidWdnZXItcnBjLWNsaWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBicGxpc3RDcmVhdGUgZnJvbSAnYnBsaXN0LWNyZWF0b3InO1xuaW1wb3J0IGJwbGlzdFBhcnNlIGZyb20gJ2JwbGlzdC1wYXJzZXInO1xuaW1wb3J0IGJ1ZmZlcnBhY2sgZnJvbSAnYnVmZmVycGFjayc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBSRU1PVEVfREVCVUdHRVJfUE9SVCB9IGZyb20gJy4vcmVtb3RlLWRlYnVnZ2VyJztcbmltcG9ydCB1dWlkIGZyb20gJ25vZGUtdXVpZCc7XG5pbXBvcnQgbmV0IGZyb20gJ25ldCc7XG5pbXBvcnQgUnBjTWVzc2FnZUhhbmRsZXIgZnJvbSAnLi9yZW1vdGUtZGVidWdnZXItbWVzc2FnZS1oYW5kbGVyJztcbmltcG9ydCBnZXRSZW1vdGVDb21tYW5kIGZyb20gJy4vcmVtb3RlLW1lc3NhZ2VzJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW1vdGVEZWJ1Z2dlclJwY0NsaWVudCB7XG4gIGNvbnN0cnVjdG9yIChob3N0LCBwb3J0ID0gUkVNT1RFX0RFQlVHR0VSX1BPUlQsIHNwZWNpYWxNZXNzYWdlSGFuZGxlcnMgPSB7fSkge1xuICAgIC8vIHNvY2tldCBhbmQgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uXG4gICAgdGhpcy5zb2NrZXQgPSBudWxsO1xuICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuY29ubklkID0gdXVpZC52NCgpO1xuICAgIHRoaXMuc2VuZGVySWQgPSB1dWlkLnY0KCk7XG4gICAgdGhpcy5jdXJNc2dJZCA9IDA7XG4gICAgdGhpcy5yZWNlaXZlZCA9IG5ldyBCdWZmZXIoMCk7XG4gICAgdGhpcy5yZWFkUG9zID0gMDtcblxuICAgIC8vIG1lc3NhZ2UgaGFuZGxlcnNcbiAgICB0aGlzLnNwZWNpYWxNZXNzYWdlSGFuZGxlcnMgPSBzcGVjaWFsTWVzc2FnZUhhbmRsZXJzO1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgY29ubmVjdCAoKSB7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG5ldyBScGNNZXNzYWdlSGFuZGxlcih0aGlzLnNwZWNpYWxNZXNzYWdlSGFuZGxlcnMpO1xuXG4gICAgLy8gY3JlYXRlIHNvY2tldCBhbmQgaGFuZGxlIGl0cyBtZXNzYWdlc1xuICAgIHRoaXMuc29ja2V0ID0gbmV3IG5ldC5Tb2NrZXQoe3R5cGU6ICd0Y3A2J30pO1xuICAgIHRoaXMuc29ja2V0LnNldE5vRGVsYXkodHJ1ZSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIGxvZy5kZWJ1ZygnRGVidWdnZXIgc29ja2V0IGRpc2Nvbm5lY3RlZCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICB9KTtcbiAgICB0aGlzLnNvY2tldC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICB0aGlzLnNvY2tldC5vbignZGF0YScsIHRoaXMucmVjZWl2ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIGNvbm5lY3QgdGhlIHNvY2tldFxuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBvbmx5IHJlc29sdmUgdGhpcyBmdW5jdGlvbiB3aGVuIHdlIGFyZSBhY3R1YWxseSBjb25uZWN0ZWRcbiAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QodGhpcy5wb3J0LCAnOjoxJyk7XG4gICAgICB0aGlzLnNvY2tldC5vbignY29ubmVjdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbG9nLmRlYnVnKGBEZWJ1Z2dlciBzb2NrZXQgY29ubmVjdGVkIHRvICR7dGhpcy5zb2NrZXQucmVtb3RlQWRkcmVzc306JHt0aGlzLnNvY2tldC5yZW1vdGVQb3J0fWApO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG5cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNvY2tldC5vbignZXJyb3InLCAoZXhjZXB0aW9uKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgIGxvZy5lcnJvcihgU29ja2V0IGVycm9yOiAke2V4Y2VwdGlvbi5tZXNzYWdlfWApO1xuICAgICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgY29ubmVjdGlvbiB3YXMgcmVmdXNlZCwgc28gcmVqZWN0IHRoZSBjb25uZWN0IHByb21pc2VcbiAgICAgICAgcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGRpc2Nvbm5lY3QgKCkge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIGxvZy5kZWJ1ZygnRGlzY29ubmVjdGluZyBmcm9tIHJlbW90ZSBkZWJ1Z2dlcicpO1xuICAgICAgdGhpcy5zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB9XG5cbiAgaXNDb25uZWN0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3RlZDtcbiAgfVxuXG4gIHNldFNwZWNpYWxNZXNzYWdlSGFuZGxlciAoa2V5LCBlcnJvckhhbmRsZXIsIGhhbmRsZXIpIHtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNldFNwZWNpYWxNZXNzYWdlSGFuZGxlcihrZXksIGVycm9ySGFuZGxlciwgaGFuZGxlcik7XG4gIH1cblxuICBzZXREYXRhTWVzc2FnZUhhbmRsZXIgKGtleSwgZXJyb3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlci5zZXREYXRhTWVzc2FnZUhhbmRsZXIoa2V5LCBlcnJvckhhbmRsZXIsIGhhbmRsZXIpO1xuICB9XG5cbiAgYWxsb3dOYXZpZ2F0aW9uV2l0aG91dFJlbG9hZCAoYWxsb3cgPSB0cnVlKSB7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlci5hbGxvd05hdmlnYXRpb25XaXRob3V0UmVsb2FkKGFsbG93KTtcbiAgfVxuXG4gIGFzeW5jIHNlbGVjdEFwcCAoYXBwSWRLZXksIGFwcGxpY2F0aW9uQ29ubmVjdGVkSGFuZGxlcikge1xuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBsb2NhbCBjYWxsYmFjaywgdGVtcG9yYXJpbHkgYWRkZWQgYXMgY2FsbGJhY2sgdG9cbiAgICAgIC8vIGBfcnBjX2FwcGxpY2F0aW9uQ29ubmVjdGVkOmAgcmVtb3RlIGRlYnVnZ2VyIHJlc3BvbnNlXG4gICAgICAvLyB0byBoYW5kbGUgdGhlIGluaXRpYWwgY29ubmVjdGlvblxuICAgICAgbGV0IG9uQXBwQ2hhbmdlID0gYXN5bmMgKGRpY3QpID0+IHtcbiAgICAgICAgLy8gZnJvbSB0aGUgZGljdGlvbmFyeSByZXR1cm5lZCwgZ2V0IHRoZSBpZHNcbiAgICAgICAgbGV0IG9sZEFwcElkS2V5ID0gZGljdC5XSVJIb3N0QXBwbGljYXRpb25JZGVudGlmaWVyS2V5O1xuICAgICAgICBsZXQgY29ycmVjdEFwcElkS2V5ID0gZGljdC5XSVJBcHBsaWNhdGlvbklkZW50aWZpZXJLZXk7XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHJlcG9ydCBvZiBhIHByb3h5IHJlZGlyZWN0IGZyb20gdGhlIHJlbW90ZSBkZWJ1Z2dlclxuICAgICAgICAvLyB3ZSB3YW50IHRvIHVwZGF0ZSBvdXIgZGljdGlvbmFyeSBhbmQgZ2V0IGEgbmV3IGFwcCBpZFxuICAgICAgICBpZiAob2xkQXBwSWRLZXkgJiYgY29ycmVjdEFwcElkS2V5ICE9PSBvbGRBcHBJZEtleSkge1xuICAgICAgICAgIGxvZy5kZWJ1ZyhgV2Ugd2VyZSBub3RpZmllZCB3ZSBtaWdodCBoYXZlIGNvbm5lY3RlZCB0byB0aGUgd3JvbmcgYXBwLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFVzaW5nIGlkICR7Y29ycmVjdEFwcElkS2V5fSBpbnN0ZWFkIG9mICR7b2xkQXBwSWRLZXl9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBsaWNhdGlvbkNvbm5lY3RlZEhhbmRsZXIoZGljdCk7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuc2V0U3BlY2lhbE1lc3NhZ2VIYW5kbGVyKCdfcnBjX2FwcGxpY2F0aW9uQ29ubmVjdGVkOicsIHJlamVjdCwgb25BcHBDaGFuZ2UpO1xuXG4gICAgICAvLyBkbyB0aGUgYWN0dWFsIGNvbm5lY3RpbmcgdG8gdGhlIGFwcFxuICAgICAgbGV0IFtjb25uZWN0ZWRBcHBJZEtleSwgcGFnZURpY3RdID0gYXdhaXQgdGhpcy5zZW5kKCdjb25uZWN0VG9BcHAnLCB7XG4gICAgICAgIGFwcElkS2V5XG4gICAgICB9KTtcblxuICAgICAgLy8gc29tZXRpbWVzIHRoZSBjb25uZWN0IGxvZ2ljIGhhcHBlbnMsIGJ1dCB3aXRoIGFuIGVtcHR5IGRpY3Rpb25hcnlcbiAgICAgIC8vIHdoaWNoIGxlYWRzIHRvIHRoZSByZW1vdGUgZGVidWdnZXIgZ2V0dGluZyBkaXNjb25uZWN0ZWQsIGFuZCBpbnRvIGEgbG9vcFxuICAgICAgaWYgKF8uaXNFbXB0eShwYWdlRGljdCkpIHtcbiAgICAgICAgbGV0IG1zZyA9ICdFbXB0eSBwYWdlIGRpY3Rpb25hcnkgcmVjZWl2ZWQnO1xuICAgICAgICBsb2cuZGVidWcobXNnKTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihtc2cpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoW2Nvbm5lY3RlZEFwcElkS2V5LCBwYWdlRGljdF0pO1xuICAgICAgfVxuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgLy8gbm8gbWF0dGVyIHdoYXQsIHdlIHdhbnQgdG8gcmVzdG9yZSB0aGUgaGFuZGxlciB0aGF0IHdhcyBjaGFuZ2VkLlxuICAgICAgdGhpcy5zZXRTcGVjaWFsTWVzc2FnZUhhbmRsZXIoJ19ycGNfYXBwbGljYXRpb25Db25uZWN0ZWQ6JywgbnVsbCwgYXBwbGljYXRpb25Db25uZWN0ZWRIYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHNlbmQgKGNvbW1hbmQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBwcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW5ldmVyIHJlbW90ZSBkZWJ1Z2dlclxuICAgICAgLy8gcmVwbGllcyB0byBvdXIgcmVxdWVzdFxuXG4gICAgICAvLyByZXRyaWV2ZSB0aGUgY29ycmVjdCBjb21tYW5kIHRvIHNlbmRcbiAgICAgIG9wdHMgPSBfLmRlZmF1bHRzKHtjb25uSWQ6IHRoaXMuY29ubklkLCBzZW5kZXJJZDogdGhpcy5zZW5kZXJJZH0sIG9wdHMpO1xuICAgICAgbGV0IGRhdGEgPSBnZXRSZW1vdGVDb21tYW5kKGNvbW1hbmQsIG9wdHMpO1xuXG4gICAgICAvLyBtb3N0IG9mIHRoZSB0aW1lIHdlIGRvbid0IGNhcmUgd2hlbiBzb2NrZXQud3JpdGUgZG9lc1xuICAgICAgLy8gc28gZ2l2ZSBpdCBhbiBlbXB0eSBmdW5jdGlvblxuICAgICAgbGV0IHNvY2tldENiID0gXy5ub29wO1xuXG4gICAgICAvLyBoYW5kbGUgc29ja2V0IHByb2JsZW1zXG4gICAgICBsZXQgb25Tb2NrZXRFcnJvciA9IChleGNlcHRpb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgbG9nLmVycm9yKGBTb2NrZXQgZXJyb3I6ICR7ZXhjZXB0aW9uLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgY29ubmVjdGlvbiB3YXMgcmVmdXNlZCwgc28gcmVqZWN0IHRoZSBjb25uZWN0IHByb21pc2VcbiAgICAgICAgcmVqZWN0KGV4Y2VwdGlvbik7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoaXMgbGlzdGVuZXIsIHNvIHdlIGRvbid0IGV4aGF1c3QgdGhlIHN5c3RlbVxuICAgICAgICB0aGlzLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvblNvY2tldEVycm9yKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnNvY2tldC5vbignZXJyb3InLCBvblNvY2tldEVycm9yKTtcbiAgICAgIGlmICh0aGlzLm1lc3NhZ2VIYW5kbGVyLmhhc1NwZWNpYWxNZXNzYWdlSGFuZGxlcihkYXRhLl9fc2VsZWN0b3IpKSB7XG4gICAgICAgIC8vIHNwZWNpYWwgcmVwbGllcyB3aWxsIHJldHVybiBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgICB0aGlzLnNldFNwZWNpYWxNZXNzYWdlSGFuZGxlcihkYXRhLl9fc2VsZWN0b3IsIHJlamVjdCwgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICBsb2cuZGVidWcoYFJlY2VpdmVkIHJlc3BvbnNlIGZyb20gc29ja2V0IHNlbmQ6ICcke18udHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoYXJncyksIDUwKX0nYCk7XG4gICAgICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25Tb2NrZXRFcnJvcik7XG4gICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5fX2FyZ3VtZW50ICYmIGRhdGEuX19hcmd1bWVudC5XSVJTb2NrZXREYXRhS2V5KSB7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIG1lc3NhZ2VzIGNvbWluZyBhbmQgZ29pbmcgdXNpbmdcbiAgICAgICAgLy8gYSBzaW1wbGUgc2VxdWVudGlhbCBpZFxuICAgICAgICB0aGlzLmN1ck1zZ0lkKys7XG4gICAgICAgIHRoaXMuc2V0RGF0YU1lc3NhZ2VIYW5kbGVyKHRoaXMuY3VyTXNnSWQudG9TdHJpbmcoKSwgcmVqZWN0LCAodmFsdWUpID0+IHtcbiAgICAgICAgICBsb2cuZGVidWcoYFJlY2VpdmVkIGRhdGEgcmVzcG9uc2UgZnJvbSBzb2NrZXQgc2VuZDogJyR7Xy50cnVuY2F0ZShKU09OLnN0cmluZ2lmeSh2YWx1ZSksIDUwKX0nYCk7XG4gICAgICAgICAgbG9nLmRlYnVnKGBPcmlnaW5hbCBjb21tYW5kOiAke2NvbW1hbmR9YCk7XG4gICAgICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25Tb2NrZXRFcnJvcik7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhLl9fYXJndW1lbnQuV0lSU29ja2V0RGF0YUtleS5pZCA9IHRoaXMuY3VyTXNnSWQ7XG4gICAgICAgIGRhdGEuX19hcmd1bWVudC5XSVJTb2NrZXREYXRhS2V5ID1cbiAgICAgICAgICAgIG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoZGF0YS5fX2FyZ3VtZW50LldJUlNvY2tldERhdGFLZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gaW1tZWRpYXRlbHkgcmVzb2x2ZSB0aGlzIHNvY2tldC53cml0ZVxuICAgICAgICAvLyBhbnkgbG9uZyB0ZXJtIGNhbGxiYWNrcyB3aWxsIGRvIHRoZWlyIGJ1c2luZXNzIGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgIHNvY2tldENiID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbG9nLmRlYnVnKGBTZW5kaW5nICcke2RhdGEuX19zZWxlY3Rvcn0nIG1lc3NhZ2UgdG8gcmVtb3RlIGRlYnVnZ2VyYCk7XG5cbiAgICAgIC8vIHJlbW90ZSBkZWJ1Z2dlciBleHBlY3RzIGEgYmluYXJ5IHBsaXN0IGFzIGRhdGFcbiAgICAgIGxldCBwbGlzdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBsaXN0ID0gYnBsaXN0Q3JlYXRlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsZXQgbXNnID0gYENvdWxkIG5vdCBjcmVhdGUgYmluYXJ5IHBsaXN0IGZyb20gZGF0YTogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgbG9nLmVycm9yKG1zZyk7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKG1zZykpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb2NrZXQgJiYgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgLy8gY29yayBhbmQgdW5jb3JrIGluIG9yZGVyIHRvIG5vdCBidWZmZXIgdGhlIHdyaXRlXG4gICAgICAgIC8vIG9uIHNvbWUgc3lzdGVtcyB0aGlzIGlzIG5lY2Vzc2FyeSBvciB0aGUgc2VydmVyXG4gICAgICAgIC8vIGdldHMgY29uZnVzZWQuXG4gICAgICAgIHRoaXMuc29ja2V0LmNvcmsoKTtcbiAgICAgICAgdGhpcy5zb2NrZXQud3JpdGUoYnVmZmVycGFjay5wYWNrKCdMJywgW3BsaXN0Lmxlbmd0aF0pKTtcbiAgICAgICAgdGhpcy5zb2NrZXQud3JpdGUocGxpc3QsIHNvY2tldENiKTtcbiAgICAgICAgdGhpcy5zb2NrZXQudW5jb3JrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgbXNnID0gJ0F0dGVtcHRlZCB0byB3cml0ZSBkYXRhIHRvIHNvY2tldCBhZnRlciBpdCB3YXMgY2xvc2VkISc7XG4gICAgICAgIGxvZy5lcnJvcihtc2cpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKG1zZykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmVjZWl2ZSAoZGF0YSkge1xuICAgIC8vIEFwcGVuZCB0aGlzIG5ldyBkYXRhIHRvIHRoZSBleGlzdGluZyBCdWZmZXJcbiAgICB0aGlzLnJlY2VpdmVkID0gQnVmZmVyLmNvbmNhdChbdGhpcy5yZWNlaXZlZCwgZGF0YV0pO1xuICAgIGxldCBkYXRhTGVmdE92ZXIgPSB0cnVlO1xuXG4gICAgLy8gUGFyc2UgbXVsdGlwbGUgbWVzc2FnZXMgaW4gdGhlIHNhbWUgcGFja2V0XG4gICAgd2hpbGUgKGRhdGFMZWZ0T3Zlcikge1xuICAgICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gd2hlcmUgd2Ugd2VyZVxuICAgICAgbGV0IG9sZFJlYWRQb3MgPSB0aGlzLnJlYWRQb3M7XG5cbiAgICAgIC8vIFJlYWQgdGhlIHByZWZpeCAocGxpc3QgbGVuZ3RoKSB0byBzZWUgaG93IGZhciB0byByZWFkIG5leHRcbiAgICAgIC8vIEl0J3MgYWx3YXlzIDQgYnl0ZXMgbG9uZ1xuICAgICAgbGV0IHByZWZpeCA9IHRoaXMucmVjZWl2ZWQuc2xpY2UodGhpcy5yZWFkUG9zLCB0aGlzLnJlYWRQb3MgKyA0KTtcblxuICAgICAgbGV0IG1zZ0xlbmd0aDtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1zZ0xlbmd0aCA9IGJ1ZmZlcnBhY2sudW5wYWNrKCdMJywgcHJlZml4KVswXTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nLmVycm9yKGBCdWZmZXIgY291bGQgbm90IHVucGFjazogJHtlfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEp1bXAgZm9yd2FyZCA0IGJ5dGVzXG4gICAgICB0aGlzLnJlYWRQb3MgKz0gNDtcblxuICAgICAgLy8gSXMgdGhlcmUgZW5vdWdoIGRhdGEgaGVyZT9cbiAgICAgIC8vIElmIG5vdCwganVtcCBiYWNrIHRvIG91ciBvcmlnaW5hbCBwb3NpdGlvbiBhbmQgZ3Rmb1xuICAgICAgaWYgKHRoaXMucmVjZWl2ZWQubGVuZ3RoIDwgbXNnTGVuZ3RoICsgdGhpcy5yZWFkUG9zKSB7XG4gICAgICAgIHRoaXMucmVhZFBvcyA9IG9sZFJlYWRQb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBFeHRyYWN0IHRoZSBtYWluIGJvZHkgb2YgdGhlIG1lc3NhZ2UgKHdoZXJlIHRoZSBwbGlzdCBzaG91bGQgYmUpXG4gICAgICBsZXQgYm9keSA9IHRoaXMucmVjZWl2ZWQuc2xpY2UodGhpcy5yZWFkUG9zLCBtc2dMZW5ndGggKyB0aGlzLnJlYWRQb3MpO1xuXG4gICAgICAvLyBFeHRyYWN0IHRoZSBwbGlzdFxuICAgICAgbGV0IHBsaXN0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGxpc3QgPSBicGxpc3RQYXJzZS5wYXJzZUJ1ZmZlcihib2R5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nLmVycm9yKGBFcnJvciBwYXJzaW5nIGJpbmFyeSBwbGlzdDogJHtlfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGJwbGlzdFBhcnNlLnBhcnNlQnVmZmVyIHJldHVybnMgYW4gYXJyYXlcbiAgICAgIGlmIChwbGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcGxpc3QgPSBwbGlzdFswXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQga2V5IG9mIFsnV0lSTWVzc2FnZURhdGFLZXknLCAnV0lSRGVzdGluYXRpb25LZXknLCAnV0lSU29ja2V0RGF0YUtleSddKSB7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChwbGlzdFtrZXldKSkge1xuICAgICAgICAgIHBsaXN0W2tleV0gPSBwbGlzdFtrZXldLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGxpc3QuX19zZWxlY3RvciA9PT0gXCJfcnBjX2FwcGxpY2F0aW9uU2VudERhdGE6XCIpIHtcbiAgICAgICAgbG9nLmRlYnVnKCdSZWNlaXZlZCBhcHBsaWNhdGlvblNlbnREYXRhIHJlc3BvbnNlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cuZGVidWcoYFJlY2VpdmluZyBkYXRhIGZyb20gcmVtb3RlIGRlYnVnZ2VyOiAnJHtKU09OLnN0cmluZ2lmeShwbGlzdCl9J2ApO1xuICAgICAgfVxuXG4gICAgICAvLyBKdW1wIGZvcndhcmQgdGhlIGxlbmd0aCBvZiB0aGUgcGxpc3RcbiAgICAgIHRoaXMucmVhZFBvcyArPSBtc2dMZW5ndGg7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBob3cgbXVjaCBidWZmZXIgaXMgbGVmdFxuICAgICAgbGV0IGxlZnRPdmVyID0gdGhpcy5yZWNlaXZlZC5sZW5ndGggLSB0aGlzLnJlYWRQb3M7XG5cbiAgICAgIC8vIElzIHRoZXJlIHNvbWUgbGVmdCBvdmVyP1xuICAgICAgaWYgKGxlZnRPdmVyICE9PSAwKSB7XG4gICAgICAgIC8vIENvcHkgd2hhdCdzIGxlZnQgb3ZlciBpbnRvIGEgbmV3IGJ1ZmZlciwgYW5kIHNhdmUgaXQgZm9yIG5leHQgdGltZVxuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgQnVmZmVyKGxlZnRPdmVyKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlZC5jb3B5KGNodW5rLCAwLCB0aGlzLnJlYWRQb3MpO1xuICAgICAgICB0aGlzLnJlY2VpdmVkID0gY2h1bms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGVtcHR5IHRoZSBidWZmZXIgYW5kIGdldCBvdXQgb2YgdGhlIGxvb3BcbiAgICAgICAgdGhpcy5yZWNlaXZlZCA9IG5ldyBCdWZmZXIoMCk7XG4gICAgICAgIGRhdGFMZWZ0T3ZlciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXNldCB0aGUgcmVhZCBwb3NpdGlvblxuICAgICAgdGhpcy5yZWFkUG9zID0gMDtcblxuICAgICAgLy8gTm93IGRvIHNvbWV0aGluZyB3aXRoIHRoZSBwbGlzdFxuICAgICAgaWYgKHBsaXN0KSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIuaGFuZGxlTWVzc2FnZShwbGlzdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0VGltZWxpbmVFdmVudEhhbmRsZXIgKHRpbWVsaW5lRXZlbnRIYW5kbGVyKSB7XG4gICAgdGhpcy50aW1lbGluZUV2ZW50SGFuZGxlciA9IHRpbWVsaW5lRXZlbnRIYW5kbGVyO1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIuc2V0VGltZWxpbmVFdmVudEhhbmRsZXIodGltZWxpbmVFdmVudEhhbmRsZXIpO1xuICB9XG59XG4iXX0=